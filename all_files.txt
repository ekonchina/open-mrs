
================================================================================
FILE: ./all_files.txt
================================================================================

================================================================================
FILE: ./pytest.ini
================================================================================
[pytest]

markers =
    api: API autotests
    debud: Debud

================================================================================
FILE: ./requirements.txt
================================================================================
pytest
requests
pydantic
faker
rstr
================================================================================
FILE: ./.gitignore
================================================================================
# PyCharm / IntelliJ IDEA
.idea/
*.iml

# Python
__pycache__/
*.py[cod]
*$py.class

# Virtual environments
.venv/
venv/
env/

# Pytest
.pytest_cache/

# Allure
allure-results/
allure-report/

# Coverage / reports
.coverage
htmlcov/
coverage.xml

# Logs
*.log

# OS
.DS_Store
Thumbs.db

# Build / dist
build/
dist/
*.egg-info/

# Environment variables
.env
.env.*

# Mypy / type checking
.mypy_cache/
.pyre/

# Jupyter
.ipynb_checkpoints/


================================================================================
FILE: ./collect_data.py
================================================================================
import os

ROOT_DIR = "."          # корневая папка
OUTPUT_FILE = "all_files.txt"

# Директории, которые нужно исключить
EXCLUDED_DIRS = {
    ".venv",
    ".git",
    "node_modules",
    "__pycache__",
    ".idea"
}

def is_binary(file_path, blocksize=512):
    try:
        with open(file_path, "rb") as f:
            return b"\0" in f.read(blocksize)
    except Exception:
        return True

with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
    for root, dirs, files in os.walk(ROOT_DIR):
        # Исключаем директории на лету
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        for file in files:
            file_path = os.path.join(root, file)

            # Пропускаем бинарные файлы
            if is_binary(file_path):
                continue

            out.write(f"\n{'='*80}\n")
            out.write(f"FILE: {file_path}\n")
            out.write(f"{'='*80}\n")

            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    out.write(f.read())
            except Exception as e:
                out.write(f"\n[ERROR READING FILE: {e}]\n")

print(f"Готово! Исключены .venv, .git, node_modules, __pycache__. Результат: {OUTPUT_FILE}")

================================================================================
FILE: ./.pytest_cache/CACHEDIR.TAG
================================================================================
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

================================================================================
FILE: ./.pytest_cache/README.md
================================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

================================================================================
FILE: ./.pytest_cache/.gitignore
================================================================================
# Created by pytest automatically.
*

================================================================================
FILE: ./.pytest_cache/v/cache/nodeids
================================================================================
[
  "help_requests/test_create_person.py::test_create_person_full_validation[payload0-expected0]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload1-expected1]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload2-expected2]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload3-expected3]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload4-expected4]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload0]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload1]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload2]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload3]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload4]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload5]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload6]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload7]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload8]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload0-expected_check0]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload1-expected_check1]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload2-expected_check2]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload3-expected_check3]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload4-expected_check4]",
  "help_requests/test_create_person.py::test_create_person_success_with_correct_validation[payload0-expected0]",
  "help_requests/test_create_person.py::test_create_person_success_with_correct_validation[payload1-expected1]",
  "help_requests/test_create_person.py::test_create_person_success_with_correct_validation[payload2-expected2]",
  "tests/api/open_msr/test_create_patient_from_existing_person.py::test_create_patient_from_existing_person",
  "tests/api/open_msr/test_create_person.py::test_create_person",
  "tests/api/open_msr/test_create_person.py::test_create_person_full_validation[create_person_request0]",
  "tests/api/open_msr/test_create_person.py::test_create_person_full_validation[create_person_request1]",
  "tests/api/open_msr/test_create_person.py::test_create_person_full_validation[create_person_request2]",
  "tests/api/open_msr/test_create_person.py::test_create_person_generated",
  "tests/api/open_msr/test_create_person.py::test_create_person_invalid[payload0-error-gender]",
  "tests/api/open_msr/test_create_person.py::test_create_person_invalid[payload1-error-birth]",
  "tests/api/open_msr/test_get_locations.py::test_get_locations",
  "tests/api/open_msr/test_get_patient_identifier_types.py::TestPatientIdentifierTyped::test_patient_identifier_types",
  "tests/api/open_msr/test_get_roles.py::TestGetRoles::test_get_roles",
  "tests/api/test_create_patient_from_existing_person.py::test_create_patient_from_existing_person_generated",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-Ps2xd#1F7E-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-7N4jl5gWJ@-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-BxL54#H7ay-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-#n57GQCd4v-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]",
  "tests/test_check.py::TestGetRoles::test_get_roles"
]
================================================================================
FILE: ./.pytest_cache/v/cache/lastfailed
================================================================================
{
  "tests/test_check.py::TestGetRoles::test_get_roles": true,
  "tests/test_check.py": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload0-expected_check0]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload1-expected_check1]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload2-expected_check2]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload3-expected_check3]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload4-expected_check4]": true,
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload5]": true,
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload2]": true,
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload4]": true,
  "tests/api/test_create_patient_from_existing_person.py::test_create_patient_from_existing_person_generated": true,
  "tests/api/open_msr/test_create_person.py::test_create_person_generated": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-Ps2xd#1F7E-USER-username-Username must be between 3 and 15 characters]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-#n57GQCd4v-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-7N4jl5gWJ@-USER-username-Username must be between 3 and 15 characters]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-BxL54#H7ay-USER-username-Username must be between 3 and 15 characters]": true
}
================================================================================
FILE: ./resources/model-comparison.properties
================================================================================
[DEFAULT]
CreatePersonRequest=PersonFullResponse:gender=gender,names[0].givenName=names[0].givenName,names[0].familyName=names[0].familyName
CreatePatientFromPersonRequest=PatientFullResponse:identifiers[0].identifier=identifiers[0].identifier,identifiers[0].preferred=identifiers[0].preferred


================================================================================
FILE: ./resources/config.properties
================================================================================
[DEFAULT]
server = http://localhost/openmrs/ws/rest
api_version = /v1
================================================================================
FILE: ./tests/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/conftest.py
================================================================================
import logging

import pytest

from src.api.fixtures.api_fixtures import *
from src.api.fixtures.objects_fixture import *








================================================================================
FILE: ./tests/api/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/open_msr/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/open_msr/test_create_patient_from_existing_person.py
================================================================================
import pytest



@pytest.mark.api
def test_create_patient_from_existing_person(api_manager):
    api_manager.admin_steps.create_patient_from_existing_person()

================================================================================
FILE: ./tests/api/open_msr/test_create_person.py
================================================================================
import pytest


from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_person_request import CreatePersonRequest, CreatePersonInvalidRequest


@pytest.mark.api
def test_create_person(api_manager):
    req = RandomModelGenerator.generate(CreatePersonRequest)
    created = api_manager.admin_steps.create_person(req)

    #TODO: убрать куда-нибудь
    assert created.uuid
    assert created.voided is False
    assert created.preferredName.uuid
    full = api_manager.admin_steps.get_person_full(created.uuid)

    # TODO: убрать куда-нибудь
    assert full.uuid == created.uuid


@pytest.mark.xfail #TODO: how fail by parametrized test
@pytest.mark.api
@pytest.mark.parametrize(
    "payload, error_key, error_value",
    [
        (
            CreatePersonInvalidRequest(
                names=[{"givenName": "John", "familyName": "Doe"}],
                gender="X",  # invalid (дока: M/F/U)
                birthdate="1997-09-02",
                addresses=[{"address1": "Street 1", "cityVillage": "City", "country": "CH", "postalCode": "8000"}],
            ),
            "error",
            "gender",
        ),
        (
            CreatePersonInvalidRequest(
                names=[{"givenName": "John", "familyName": "Doe"}],
                gender="M",
                birthdate="1997-99-99",  # invalid date
                addresses=[{"address1": "Street 1", "cityVillage": "City", "country": "CH", "postalCode": "8000"}],
            ),
            "error",
            "birth",
        ),
    ],
)
def test_create_person_invalid(api_manager, payload, error_key, error_value):
    api_manager.admin_steps.create_invalid_person(
        create_person_request=payload,
        error_key=error_key,
        error_value=error_value,
    )
================================================================================
FILE: ./src/__init__.py
================================================================================

================================================================================
FILE: ./src/api/__init__.py
================================================================================

================================================================================
FILE: ./src/api/classes/__init__.py
================================================================================

================================================================================
FILE: ./src/api/classes/api_manager.py
================================================================================
from src.api.steps.admin_steps import AdminSteps


class ApiManager:
    def __init__(self, create_object: list):
        self.admin_steps = AdminSteps(create_object)

================================================================================
FILE: ./src/api/specs/response_spec.py
================================================================================
from collections.abc import Callable
from http import HTTPStatus
from json import JSONDecodeError

from requests import Response


class ResponseSpecs:

    @staticmethod
    def request_returns_ok() -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.OK, response.text
        return check

    @staticmethod
    def entity_was_created() -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.CREATED, response.text
        return check

    @staticmethod
    def entity_was_deleted() -> Callable:
        def check(response: Response):
            assert response.status_code in (HTTPStatus.CREATED, HTTPStatus.OK, HTTPStatus.NO_CONTENT), response.text
        return check


    @staticmethod
    def request_returns_bad_request(error_key: str, error_value: str) -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.BAD_REQUEST, response.text

            try:
                error_content = response.json().get(error_key)
            except JSONDecodeError:
                error_content = response.content
            error_text = str(error_content)

            assert error_value in error_text

        return check


================================================================================
FILE: ./src/api/specs/__init__.py
================================================================================

================================================================================
FILE: ./src/api/specs/request_spec.py
================================================================================
import base64



class RequestSpecs:

    @staticmethod
    def default_request_headers():
        return {
            'Content-Type': 'application/json',
            'Authorization': 'Basic YWRtaW46YWRtaW4=',
        }

    @staticmethod
    def unauth_spec():
        return RequestSpecs.default_request_headers()

    @staticmethod
    def admin_auth_spec():
        raw = "admin:Admin123"
        token = base64.b64encode(raw.encode()).decode()
        headers = RequestSpecs.default_request_headers()
        headers["authorization"] = f"Basic {token}"
        return headers




================================================================================
FILE: ./src/api/models/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/base_model.py
================================================================================
from pydantic import BaseModel as BM

class BaseModel(BM):...
================================================================================
FILE: ./src/api/models/responses/get_location_response.py
================================================================================
from typing import List, Optional
from src.api.models.base_model import BaseModel


class LocationLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str]


class LocationResult(BaseModel):
    uuid: str
    display: str
    links: List[LocationLink]


class LocationListLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str]


class LocationListResponse(BaseModel):
    results: List[LocationResult]
    links: Optional[List[LocationListLink]] = None

================================================================================
FILE: ./src/api/models/responses/patient_identifier_type_response.py
================================================================================
from typing import List
from src.api.models.base_model import BaseModel


class PatientIdentifierTypeLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: str


class PatientIdentifierTypeResult(BaseModel):
    uuid: str
    display: str
    links: List[PatientIdentifierTypeLink]


class PatientIdentifierTypeListResponse(BaseModel):
    results: List[PatientIdentifierTypeResult]

================================================================================
FILE: ./src/api/models/responses/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/responses/create_person_response.py
================================================================================
from typing import List, Optional, Any
from src.api.models.base_model import BaseModel

#TODO: понять с full
class Link(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str] = None


class PreferredName(BaseModel):
    uuid: str
    display: Optional[str] = None
    links: Optional[List[Link]] = None


class CreatPersonResponse(BaseModel):
    uuid: str
    display: str
    gender: str
    voided: bool
    preferredName: PreferredName
    links: List[Link]
    resourceVersion: Optional[str] = None


# Для v=full удобнее взять “мягкую” модель (т.к. полей много и они могут отличаться)
class PersonFullResponse(BaseModel):
    uuid: str
    display: str
    gender: str
    voided: bool

    # поля, которые точно встречаются в full
    names: List[Any]
    attributes: List[Any]
    birthdateEstimated: bool
    dead: bool
    deathdateEstimated: bool

    preferredName: Any
    links: List[Link]

================================================================================
FILE: ./src/api/models/responses/get_roles_response.py
================================================================================
from typing import List
from src.api.models.base_model import BaseModel


class RoleLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: str


class RoleResult(BaseModel):
    uuid: str
    display: str
    links: List[RoleLink]


class RoleListResponse(BaseModel):
    results: List[RoleResult]

================================================================================
FILE: ./src/api/models/responses/create_patient_response.py
================================================================================
from typing import List, Optional, Any
from src.api.models.base_model import BaseModel

class Link(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str] = None


class PatientCreateResponse(BaseModel):
    uuid: str
    display: Optional[str] = None
    links: Optional[List[Link]] = None



class PatientIdentifierResponse(BaseModel):
    uuid: str
    display: Optional[str] = None
    identifier: Optional[str] = None
    preferred: Optional[bool] = None
    identifierType: Optional[Any] = None
    location: Optional[Any] = None

class PatientFullResponse(BaseModel):
    uuid: str
    display: str
    identifiers: Optional[List[PatientIdentifierResponse]] = None

================================================================================
FILE: ./src/api/models/requests/update_profile_request.py
================================================================================
from typing import Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class UpdateProfileRequest(BaseModel):
    name: Annotated[str, GeneratingRule(regex=r"^[A-Za-z]+ [A-Za-z]+$")]

================================================================================
FILE: ./src/api/models/requests/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/requests/create_patient_from_person_request.py
================================================================================
from typing import List, Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class PatientIdentifierRequest(BaseModel):
    # В OpenMRS identifier — произвольная строка, но пусть будет "безопасная" генерация
    identifier: Annotated[str, GeneratingRule(regex=r"^[A-Za-z0-9]{5,12}$")]
    identifierType: str  # uuid
    location: str        # uuid
    preferred: bool = False


class CreatePatientFromPersonRequest(BaseModel):
    person: str  # uuid существующей Person
    identifiers: List[PatientIdentifierRequest]

================================================================================
FILE: ./src/api/models/requests/create_person_request.py
================================================================================
from typing import List, Optional, Annotated, Any

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel

#TODO: Тут генерировать данные
class PersonNameRequest(BaseModel):
    # по доке: givenName, familyName :contentReference[oaicite:1]{index=1}
    givenName: Annotated[str, GeneratingRule(regex=r"^[A-Z][a-z]{2,12}$")]
    familyName: Annotated[str, GeneratingRule(regex=r"^[A-Z][a-z]{2,16}$")]


class PersonAddressRequest(BaseModel):
    # по доке (пример): address1, cityVillage, country, postalCode :contentReference[oaicite:2]{index=2}
    address1: Annotated[str, GeneratingRule(regex=r"^[A-Za-z0-9 ,.-]{5,60}$")]
    cityVillage: Annotated[str, GeneratingRule(regex=r"^[A-Za-z .-]{2,40}$")]
    country: Annotated[str, GeneratingRule(regex=r"^[A-Za-z .-]{2,40}$")]
    postalCode: Annotated[str, GeneratingRule(regex=r"^[0-9]{4,10}$")]


class CreatePersonRequest(BaseModel):
    # по доке: names[] :contentReference[oaicite:3]{index=3}
    names: List[PersonNameRequest]

    # по доке: gender "M" (в примере) :contentReference[oaicite:4]{index=4}
    gender: Annotated[str, GeneratingRule(regex=r"^(M|F|U)$")]

    # по доке (пример): birthdate "YYYY-MM-DD" :contentReference[oaicite:5]{index=5}
    birthdate: Annotated[str, GeneratingRule(regex=r"^(19|20)\d{2}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$")]

    # по доке: addresses[] :contentReference[oaicite:6]{index=6}
    addresses: List[PersonAddressRequest]

class CreatePersonInvalidRequest(BaseModel):
    # Любые значения, чтобы можно было отправлять "плохие" payload'ы
    names: Any = None
    gender: Any = None
    birthdate: Any = None
    addresses: Any = None
================================================================================
FILE: ./src/api/models/comparison/model_assertions.py
================================================================================
from typing import Any

from src.api.models.comparison.model_comparator import ModelComparator
from src.api.models.comparison.model_comparison_configuration import ModelComparisonConfigLoader


class ModelAssertions:
    def __init__(self, request: Any, response: Any):
        self.request = request
        self.response = response

    def match(self) -> 'ModelAssertions':
        config_loader = ModelComparisonConfigLoader('model-comparison.properties')
        rule = config_loader.get_rule_for(self.request)
        if rule:
            result = ModelComparator.compare_fields(self.request, self.response, rule.field_mapping
                                                    )
            if not result.is_success():
                raise AssertionError(f'Model comparison failed with mismatches fields \n {result.mismatches}')
        else:
            raise AssertionError(f'Model comparison rule found for   \n {self.request.__class__.__name__}')
        return self
================================================================================
FILE: ./src/api/models/comparison/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/comparison/model_comparator.py
================================================================================
from typing import Any, Dict, List
from dataclasses import dataclass
import re

@dataclass
class Mismatch:
    field_name: str
    expected: Any
    actual: Any

class ComparisonResult:
    def __init__(self, mismatches: List [Mismatch]):
        self._mismatches =  mismatches

    def is_success(self) -> bool:
        return not self.mismatches

    @property
    def mismatches(self)->List [Mismatch]:
        return self._mismatches

class ModelComparator:
    @staticmethod
    def compare_fields(request: Any, response: Any, field_mapping: Dict[str,str]):
        mismatches = []
        for request_field, response_field in field_mapping.items():
            request_value = ModelComparator._get_field_value(request, request_field)
            response_value = ModelComparator._get_field_value(response, response_field)
            if str(request_value)!=str(response_value):
                mismatches.append(Mismatch(f'{request_field} -> {response_field}', request_value, response_value))
        return ComparisonResult(mismatches)

    @staticmethod
    def _get_field_value(obj: Any, path: str) -> Any:
        """
        Поддерживает пути вида:
        - gender
        - names[0].givenName
        - names[0].familyName
        """
        current = obj

        for part in path.split("."):
            # names[0]
            match = re.match(r"(\w+)\[(\d+)\]", part)
            if match:
                attr_name, index = match.groups()
                index = int(index)

                # attr
                if isinstance(current, dict):
                    current = current[attr_name]
                else:
                    current = getattr(current, attr_name)

                # index
                current = current[index]
            else:
                # обычное поле
                if isinstance(current, dict):
                    current = current[part]
                else:
                    current = getattr(current, part)

        return current

================================================================================
FILE: ./src/api/models/comparison/model_comparison_configuration.py
================================================================================
import os
from pathlib import Path
import configparser
from typing import Dict, Type, Optional


from typing import Dict

class ComparisonRule:
    def __init__(self, response_class_name: str, field_pairs: list[str]):
        self._response_class_name = response_class_name
        self._field_mapping: Dict[str, str] = {}

        for pair in field_pairs:
            parts = pair.split('=')
            if len(parts) == 2:
                self._field_mapping[parts[0].strip()] = parts[1].strip()
            else:
                key = pair.strip()
                self._field_mapping[key] = key

    @property
    def response_class_name(self) -> str:
        return self._response_class_name

    @property
    def field_mapping(self) -> Dict[str, str]:
        return self._field_mapping


class ModelComparisonConfigLoader:
    def __init__(self, config_file: str):
        self.rules : Dict[str, ComparisonRule]= {}
        self._load_config(config_file=config_file)

    def get_rule_for(self, request_class: Type) -> Optional[ComparisonRule]:
        return self.rules.get(type(request_class).__name__)

    def _load_config(self, config_file: str):
        config_path = Path(__file__).parents[4]/"resources" / f'{config_file}'
        if not os.path.exists(config_path):
            raise FileNotFoundError(f'Config file not found')

        config = configparser.ConfigParser()
        config.optionxform = str
        config.read(config_path)

        for key in config.defaults():
            value = config.defaults()[key]
            target = value.split(':')
            if len(target)!= 2:
                continue
            response_class = target[0].strip()
            field_list = [field.strip()  for field in target[1].split(',')]
            self.rules[key.strip()] = ComparisonRule(response_class, field_list)




================================================================================
FILE: ./src/api/requests/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/endpoint.py
================================================================================
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from src.api.models.base_model import BaseModel
from src.api.models.requests.create_patient_from_person_request import CreatePatientFromPersonRequest
from src.api.models.requests.create_person_request import CreatePersonRequest
from src.api.models.responses.create_patient_response import PatientFullResponse, PatientCreateResponse
from src.api.models.responses.create_person_response import CreatPersonResponse, PersonFullResponse
from src.api.models.responses.get_location_response import LocationListResponse
from src.api.models.responses.get_roles_response import RoleListResponse
from src.api.models.responses.patient_identifier_type_response import PatientIdentifierTypeListResponse


@dataclass(frozen=True)
class EndpointConfig:
    url:str
    request_model:Optional[BaseModel]
    response_model:Optional[BaseModel]

class Endpoint(Enum):
    GET_ROLES = EndpointConfig(
        url="/role",
        request_model=None,
        response_model=RoleListResponse
    )

    GET_LOCATIONS = EndpointConfig(
        url="/location",
        request_model=None,
        response_model=LocationListResponse
    )

    GET_PATIENT_IDENTIFIER_TYPES = EndpointConfig(
        url="/patientidentifiertype",
        request_model=None,
        response_model=PatientIdentifierTypeListResponse
    )
    CREATE_PERSON = EndpointConfig(
        url="/person",
        request_model=CreatePersonRequest,
        response_model=CreatPersonResponse
    )

    GET_PERSON = EndpointConfig(
        url="/person",
        request_model=None,
        response_model=PersonFullResponse
    )

    DELETE_PERSON = EndpointConfig(
        url="/person",
        request_model=None,
        response_model=None
    )

    CREATE_PATIENT_FROM_PERSON = EndpointConfig(
        url="/patient",
        request_model=CreatePatientFromPersonRequest,
        response_model=PatientCreateResponse
    )

    DELETE_PATIENT = EndpointConfig(
        url="/patient",
        request_model=None,
        response_model=None
    )

    GET_PATIENT = EndpointConfig(
        url="/patient",
        request_model=None,
        response_model=PatientFullResponse  # добавим модель ниже
    )
================================================================================
FILE: ./src/api/requests/sceleton/http_request.py
================================================================================
from collections.abc import Callable
from typing import Protocol, Dict

from src.api.requests.sceleton.endpoint import Endpoint


class HTTPRequest(Protocol):
    def __init__(self, request_spec: Dict[str,str], endpoint: Endpoint, response_spec: Callable):
        self.request_spec = request_spec
        self.endpoint = endpoint
        self.response_spec = response_spec
================================================================================
FILE: ./src/api/requests/sceleton/requesters/validated_crud_requester.py
================================================================================
from typing import TypeVar, Dict, Callable, Optional, Any

from src.api.models.base_model import BaseModel
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.http_request import HTTPRequest
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester

T = TypeVar('T', bound=BaseModel)


class ValidatedCrudRequester(HTTPRequest):
    def __init__(self, request_spec: Dict[str, str], endpoint: Endpoint, response_spec: Callable):
        super().__init__(request_spec, endpoint, response_spec)
        self.crud_requester = CrudRequester(request_spec = request_spec, endpoint = endpoint, response_spec = response_spec)

    def post(self, model: Optional[T] = None):
        response = self.crud_requester.post(model= model)
        return self.endpoint.value.response_model.model_validate(response.json())

    def get(self, id: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        response = self.crud_requester.get(id=id, params=params)
        return self.endpoint.value.response_model.model_validate(response.json())

    def update(self,  model: T):
        response = self.crud_requester.update(model=model)
        return self.endpoint.value.response_model.model_validate(response.json())


================================================================================
FILE: ./src/api/requests/sceleton/requesters/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/requesters/crud_requester.py
================================================================================
from http import HTTPStatus
from typing import Protocol, Optional, Union, TypeVar, Dict, Any

import requests
from requests import Response

from src.api.configs.config import Config
from src.api.models.base_model import BaseModel
from src.api.requests.sceleton.http_request import HTTPRequest
from src.api.requests.sceleton.interfaces.crud_end_interface import CrudEndPointInterface

#дженерик, позволяющий сохранять строгую типизацию
T = TypeVar('T', bound=BaseModel)

class CrudRequester(HTTPRequest, CrudEndPointInterface):
    #TODO мы же наслодовались тут почему возвращаемы тип другой - не бейс модел
    def post(self, model: Optional[T]) -> Response:
        #TODO: optimize
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')


        body = model.model_dump() if model else ''
        response = requests.post(url=f'{server_url}{api_version_url}{self.endpoint.value.url}',
                                 headers=self.request_spec, json=body)
        self.response_spec(response)
        return response



    def get(self, model: Optional[BaseModel] = None, id: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}'
        if id:
            url = f"{url}/{id}"

        response = requests.get(url=url, headers=self.request_spec, params=params)
        self.response_spec(response)
        return response

    def update(self, model: Optional[BaseModel] = None) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}'
        body = model.model_dump() if model else {}

        response = requests.put(
            url=url,
            headers=self.request_spec,
            json=body
        )

        self.response_spec(response)
        return response

    #TODO мы же наслодовались тут почему возвращаемы тип другой - не бейс модел
    def delete(self, id: int) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        response = requests.delete(url=f'{server_url}{api_version_url}{self.endpoint.value.url}/{id}',
                                 headers=self.request_spec)
        self.response_spec(response)
        return response

    def delete_with_params(self, id: str, params: Optional[Dict[str, Any]] = None) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}/{id}'
        response = requests.delete(url=url, headers=self.request_spec, params=params)
        self.response_spec(response)
        return response

================================================================================
FILE: ./src/api/requests/sceleton/interfaces/crud_end_interface.py
================================================================================
from typing import Protocol, Optional, Union

from src.api.models.base_model import BaseModel


class CrudEndPointInterface(Protocol):
    def post(self, model: BaseModel) -> BaseModel: ...

    def get(self, model: Optional[BaseModel] = None, id : Optional[int] = None) -> BaseModel: ...

    def update(self, model: Optional[BaseModel] = None, id: Optional[int] = None) -> BaseModel: ...

    def delete(self, id: int) -> Union[BaseModel, bool]: ...

================================================================================
FILE: ./src/api/steps/__init__.py
================================================================================

================================================================================
FILE: ./src/api/steps/admin_steps.py
================================================================================
from typing import Union

from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.comparison.model_assertions import ModelAssertions
from src.api.models.requests.create_patient_from_person_request import CreatePatientFromPersonRequest, \
    PatientIdentifierRequest
from src.api.models.requests.create_person_request import CreatePersonRequest, CreatePersonInvalidRequest
from src.api.models.responses.create_patient_response import PatientFullResponse, PatientCreateResponse
from src.api.models.responses.create_person_response import CreatPersonResponse, PersonFullResponse
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.requests.sceleton.requesters.validated_crud_requester import ValidatedCrudRequester
from src.api.specs.request_spec import RequestSpecs
from src.api.specs.response_spec import ResponseSpecs
from src.api.steps.base_steps import BaseSteps





class AdminSteps(BaseSteps):

    def get_roles(self):
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_ROLES,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    def get_locations(self):
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_LOCATIONS,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    def get_patient_identifier_types(self):
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_PATIENT_IDENTIFIER_TYPES,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    def create_person(self, create_person_request: CreatePersonRequest) -> CreatPersonResponse:
        person = ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.CREATE_PERSON,
            response_spec=ResponseSpecs.entity_was_created()
        ).post(create_person_request)

        full = self.get_person_full(person.uuid)
        ModelAssertions(create_person_request, full).match()
        self.created_objects.append(person)
        return person

    def get_person_full(self, person_uuid: str) -> PersonFullResponse:
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_PERSON,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get(id=person_uuid, params={"v": "full"})

    def delete_person(self, person_uuid: str, purge: bool = True):
        params = {"purge": "true"} if purge else None

        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.DELETE_PERSON,
            response_spec=ResponseSpecs.entity_was_deleted()
        ).delete_with_params(id=person_uuid, params=params)

    def get_patient_full(self, patient_uuid: str) -> PatientFullResponse:
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_PATIENT,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get(id=patient_uuid, params={"v": "full"})

    def create_patient_from_person(self, req: CreatePatientFromPersonRequest) -> PatientCreateResponse:
        patient_created = ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.CREATE_PATIENT_FROM_PERSON,
            response_spec=ResponseSpecs.entity_was_created()
        ).post(req)

        assert patient_created.uuid, f"patient_created.uuid is falsy: {patient_created}"
        assert str(patient_created.uuid).lower() != "null", f"uuid returned as 'null': {patient_created}"

        # <-- ключевая часть
        patient_full = self.get_patient_full(patient_created.uuid)

        ModelAssertions(req, patient_full).match()

        self.created_objects.append(patient_created)
        return patient_created

    def delete_patient(self, patient_uuid: str, purge: bool = True):
        params = {"purge": "true"} if purge else None
        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.DELETE_PATIENT,
            response_spec=ResponseSpecs.entity_was_deleted()
        ).delete_with_params(id=patient_uuid, params=params)

    def create_invalid_person(self, create_person_request: CreatePersonInvalidRequest, error_key, error_value):
        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.CREATE_PERSON,
            response_spec=ResponseSpecs.request_returns_bad_request(error_key, error_value),
        ).post(create_person_request)

    def create_patient_from_existing_person(
        self,
        create_person_request: CreatePersonRequest | None = None,
        identifier_request: PatientIdentifierRequest | None = None,
    ):
        # 1) person
        create_person_request = create_person_request or RandomModelGenerator.generate(CreatePersonRequest)
        created_person = self.create_person(create_person_request)

        types = self.get_patient_identifier_types()
        identifier_type_uuid = types.results[0].uuid

        locations = self.get_locations()
        location_uuid = locations.results[0].uuid

        # 2) identifier
        identifier = identifier_request or RandomModelGenerator.generate(PatientIdentifierRequest)
        identifier.identifierType = identifier_type_uuid
        identifier.location = location_uuid
        identifier.preferred = True

        # 3) patient
        req = CreatePatientFromPersonRequest(person=created_person.uuid, identifiers=[identifier])
        created_patient = self.create_patient_from_person(req)

        assert created_patient.uuid
        assert created_patient.display

        return created_patient







================================================================================
FILE: ./src/api/steps/base_steps.py
================================================================================
from typing import List, Any


class BaseSteps:
    def __init__(self, created_objects: List[Any]):
        self.created_objects = created_objects
================================================================================
FILE: ./src/api/configs/config.py
================================================================================
import configparser
from pathlib import Path
from typing import Any


class Config:
    config = None
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Config, cls).__new__(cls)
            config_path = Path(__file__).parents[3]/"resources"/"config.properties"

            cls.config = configparser.ConfigParser()
            cls.config.read(config_path)
        return cls._instance

    @staticmethod
    def get(key:str, default_value: Any = None):
        return Config().config["DEFAULT"].get(key, fallback=default_value)



================================================================================
FILE: ./src/api/configs/__init__.py
================================================================================

================================================================================
FILE: ./src/api/fixtures/api_fixtures.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager


@pytest.fixture
def api_manager(created_objects) -> ApiManager:
    return ApiManager(created_objects)
================================================================================
FILE: ./src/api/fixtures/objects_fixture.py
================================================================================
import logging

import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.responses.create_patient_response import PatientCreateResponse
from src.api.models.responses.create_person_response import CreatPersonResponse


def cleanup_object(objects: list):
    api_manager = ApiManager(objects)
    for obj in objects:
        if isinstance(obj, CreatPersonResponse):
            api_manager.admin_steps.delete_person(obj.uuid, purge=True)
        elif isinstance(obj, PatientCreateResponse):
            api_manager.admin_steps.delete_patient(obj.uuid, purge=True)
        else:
            logging.warning(f'Object type: {type(obj)} is not deleted')


@pytest.fixture
def created_objects():
    objects: list = []
    yield objects
    cleanup_object(objects)
================================================================================
FILE: ./src/api/generators/random_model_generator.py
================================================================================
import random
import uuid
from datetime import datetime, timedelta
from typing import get_type_hints, Any, get_origin, Annotated, get_args, Union
from datetime import date, timedelta


import rstr

from src.api.generators.generating_rule import GeneratingRule
from src.api.generators.mod30 import generate_mod30_identifier, luhn_mod_n_is_valid
from src.api.models.requests.create_patient_from_person_request import PatientIdentifierRequest


class RandomModelGenerator:
    @staticmethod
    def generate(cls: type) -> Any:
        type_hints = get_type_hints(cls, include_extras=True)
        init_data = {}

        for field_name, annotated_type in type_hints.items():
            rule = None
            actual_type = annotated_type

            if get_origin(annotated_type) is Annotated:
                actual_type, *annotations = get_args(annotated_type)
                for ann in annotations:
                    if isinstance(ann, GeneratingRule):
                        rule = ann

            if cls is PatientIdentifierRequest and field_name == "identifier":
                value = generate_mod30_identifier(total_len=random.randint(6, 12))
                assert luhn_mod_n_is_valid(value), f"Generated invalid Mod-30 id: {value}"
                init_data[field_name] = value
                continue

            if field_name == "birthdate" and actual_type is str:
                days_ago = random.randint(0, 365 * 90)
                d = date.today() - timedelta(days=days_ago)
                init_data[field_name] = d.isoformat()
                continue

            if rule:
                value = RandomModelGenerator._generate_from_regex(
                    rule.regex,
                    actual_type
                )
            else:
                value = RandomModelGenerator._generate_value(actual_type)
            init_data[field_name] = value
        return cls(**init_data)


    @staticmethod
    def _generate_from_regex(regex: str, field_type: type) -> Any:
        generated = rstr.xeger(regex)

        if field_type is int:
            return int(generated)

        if field_type is float:
            return float(generated)

        return generated

    @staticmethod
    def _generate_value(field_type: Any) -> Any:
        origin = get_origin(field_type)

        if origin is Union:
            args = [a for a in get_args(field_type)]
            non_none = [a for a in args if a is not type(None)]
            if not non_none or random.random() < 0.2:
                return None
            return RandomModelGenerator._generate_value(non_none[0])

        if origin in (list,):
            (item_type,) = get_args(field_type) or (str,)
            return [RandomModelGenerator._generate_value(item_type)]

        if field_type is str:
            return str(uuid.uuid4())[:8]
        elif field_type is int:
            return random.randint(0, 1000)
        elif field_type is float:
            return round(random.uniform(0, 100.0), 2)
        elif field_type is bool:
            return random.choice([True, False])
        elif field_type is datetime:
            return datetime.now() - timedelta(seconds=random.randint(0, 100000))

        if isinstance(field_type, type):
            return RandomModelGenerator.generate(field_type)

        return None



================================================================================
FILE: ./src/api/generators/__init__.py
================================================================================

================================================================================
FILE: ./src/api/generators/generating_rule.py
================================================================================
from dataclasses import dataclass

@dataclass
class GeneratingRule:
    regex: str
================================================================================
FILE: ./src/api/generators/mod30.py
================================================================================
from __future__ import annotations

import random
from typing import Final

# charset из практики OpenMRS Mod-30 (без B I O Q S Z)
MOD30_ALPHABET: Final[str] = "0123456789ACDEFGHJKLMNPRTUVWXY"

def luhn_mod_n_check_char(body: str, alphabet: str = MOD30_ALPHABET) -> str:
    """
    Возвращает check-character для Luhn mod N (N = len(alphabet)),
    предполагая что body состоит ТОЛЬКО из символов alphabet.
    """
    n = len(alphabet)
    if n % 2 != 0:
        raise ValueError("Luhn mod N requires even N (alphabet length must be even).")

    # индекс символа -> code point
    idx = {ch: i for i, ch in enumerate(alphabet)}

    factor = 2
    total = 0

    # идём справа налево по body
    for ch in reversed(body):
        try:
            code_point = idx[ch]
        except KeyError:
            raise ValueError(f"Invalid char {ch!r} for alphabet") from None

        addend = factor * code_point
        factor = 1 if factor == 2 else 2

        # "сумма цифр" в базе n
        addend = (addend // n) + (addend % n)
        total += addend

    remainder = total % n
    check_code_point = (n - remainder) % n
    return alphabet[check_code_point]


def luhn_mod_n_is_valid(value: str, alphabet: str = MOD30_ALPHABET) -> bool:
    """
    Проверяет строку, где последний символ — check-character.
    """
    n = len(alphabet)
    if n % 2 != 0 or len(value) < 2:
        return False

    idx = {ch: i for i, ch in enumerate(alphabet)}
    factor = 1
    total = 0

    for ch in reversed(value):
        if ch not in idx:
            return False
        code_point = idx[ch]
        addend = factor * code_point
        factor = 1 if factor == 2 else 2
        addend = (addend // n) + (addend % n)
        total += addend

    return (total % n) == 0


def generate_mod30_identifier(total_len: int = 10, alphabet: str = MOD30_ALPHABET) -> str:
    """
    total_len — полная длина идентификатора (включая check-character).
    """
    if total_len < 2:
        raise ValueError("total_len must be >= 2")

    body_len = total_len - 1
    body = "".join(random.choice(alphabet) for _ in range(body_len))
    check = luhn_mod_n_check_char(body, alphabet)
    return body + check
