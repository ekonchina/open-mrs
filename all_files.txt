
================================================================================
FILE: ./all_files.txt
================================================================================

================================================================================
FILE: ./pytest.ini
================================================================================
[pytest]

markers =
    api: API autotests
    debud: Debud

================================================================================
FILE: ./requirements.txt
================================================================================
pytest
requests
pydantic
faker
rstr
================================================================================
FILE: ./.gitignore
================================================================================
# PyCharm / IntelliJ IDEA
.idea/
*.iml

# Python
__pycache__/
*.py[cod]
*$py.class

# Virtual environments
.venv/
venv/
env/

# Pytest
.pytest_cache/

# Allure
allure-results/
allure-report/

# Coverage / reports
.coverage
htmlcov/
coverage.xml

# Logs
*.log

# OS
.DS_Store
Thumbs.db

# Build / dist
build/
dist/
*.egg-info/

# Environment variables
.env
.env.*

# Mypy / type checking
.mypy_cache/
.pyre/

# Jupyter
.ipynb_checkpoints/

================================================================================
FILE: ./collect_data.py
================================================================================
import os

ROOT_DIR = "."          # корневая папка
OUTPUT_FILE = "all_files.txt"

# Директории, которые нужно исключить
EXCLUDED_DIRS = {
    ".venv",
    ".git",
    "node_modules",
    "__pycache__",
    ".idea"
}

def is_binary(file_path, blocksize=512):
    try:
        with open(file_path, "rb") as f:
            return b"\0" in f.read(blocksize)
    except Exception:
        return True

with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
    for root, dirs, files in os.walk(ROOT_DIR):
        # Исключаем директории на лету
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        for file in files:
            file_path = os.path.join(root, file)

            # Пропускаем бинарные файлы
            if is_binary(file_path):
                continue

            out.write(f"\n{'='*80}\n")
            out.write(f"FILE: {file_path}\n")
            out.write(f"{'='*80}\n")

            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    out.write(f.read())
            except Exception as e:
                out.write(f"\n[ERROR READING FILE: {e}]\n")

print(f"Готово! Исключены .venv, .git, node_modules, __pycache__. Результат: {OUTPUT_FILE}")

================================================================================
FILE: ./.pytest_cache/CACHEDIR.TAG
================================================================================
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

================================================================================
FILE: ./.pytest_cache/README.md
================================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

================================================================================
FILE: ./.pytest_cache/.gitignore
================================================================================
# Created by pytest automatically.
*

================================================================================
FILE: ./.pytest_cache/v/cache/nodeids
================================================================================
[
  "tests/api/test_create_account.py::TestCreateAccount::test_create_valid_account",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-5CI1@ve8uU-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-9UdB#lN64i-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-EF35Va4c$g-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-verysTRongPassword33$-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-yFq#E1i89I-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-K12u$mhUR0-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-fi%5S0NPd4-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-mU$i6AGf20-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-mx73M$W6Yp-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-verysTRongPassword33$-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-1L7yAFg8m$-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-ExjO%649Fc-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-Qt1GbZq3!4-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-lD%6jPL7t1-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-verysTRongPassword33$-USER-username-Username must be between 3 and 15 characters]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-$rc3Db97MW-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-0dWI!71jcA-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-7Q#1njB3Np-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-GhF1bf47$Z-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-verysTRongPassword33$-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]",
  "tests/api/test_create_user.py::TestCreateUser::test_create_valid_user",
  "tests/api/test_create_user.py::TestCreateUser::test_create_valid_user[create_user_request0]",
  "tests/api/test_fund_deposit.py::TestFundDeposit::test_fund_deposit",
  "tests/api/test_get_customer_profile.py::TestLogin::test_get_customer_profile",
  "tests/api/test_login_user.py::TestLogin::test_login_admin_user",
  "tests/api/test_login_user.py::TestLogin::test_login_user",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name[update_profile_request0]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John  Doe-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John Doe Jr-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John Doe!-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John-Doe Smith-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John1 Doe-name-Name must contain two words with letters only]",
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[\\u0418\\u0432\\u0430\\u043d \\u0418\\u0432\\u0430\\u043d\\u043e\\u0432-name-Name must contain two words with letters only]"
]
================================================================================
FILE: ./.pytest_cache/v/cache/lastfailed
================================================================================
{
  "tests/api/test_login_user.py": true,
  "tests/api/test_create_user.py": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[-5CI1@ve8uU-USER-username-Username must be between 3 and 15 characters]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[qwerty@-0dWI!71jcA-USER-username-Username must contain only letters, digits, dashes, underscores, and dots]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[ka-fi%5S0NPd4-USER-username-Username must be between 3 and 15 characters]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_invalid_user[kakakakakakakaka-ExjO%649Fc-USER-username-Username must be between 3 and 15 characters]": true,
  "tests/api/test_create_user.py::TestCreateUser::test_create_valid_user": true,
  "tests/api/test_update_customer_profile.py::TestUpdateCustomerProfile::test_update_user_name_invalid[John-Doe Smith-name-Name must contain two words with letters only]": true
}
================================================================================
FILE: ./resources/model-comparison.properties
================================================================================
[DEFAULT]
CreateUserRequest=CreateUserResponse:username = username,role=role
LoginUserRequest=LoginUserResponse:username = username

================================================================================
FILE: ./resources/config.properties
================================================================================
[DEFAULT]
server = http://localhost:4111/api
api_version = /v1
backend_url = http://localhost:4111/api/v1
================================================================================
FILE: ./tests/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/conftest.py
================================================================================
import logging

import pytest

from src.api.fixtures.api_fixtures import *
from src.api.fixtures.user_fixtures import *
from src.api.fixtures.objects_fixture import *

from src.api.models.responses.create_user_response import UserProfileResponse


def cleanup_object(objects: list):
    api_manager = ApiManager(objects)
    for obj in objects:
        if isinstance(obj, UserProfileResponse):
            api_manager.admin_steps.delete_user(obj.id)
        else:
            logging.warning(f'Object type: {type(obj)} is not deleted')


@pytest.fixture
def created_objects():
    objects: list = []
    yield objects
    cleanup_object(objects)





================================================================================
FILE: ./tests/api/test_get_customer_profile.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.mark.api
class TestLogin:

    #сравнение полей

    def test_get_customer_profile(self, user_request: CreateUserRequest, api_manager: ApiManager):
        api_manager.user_steps.get_customer_profile(create_user_request=user_request)


================================================================================
FILE: ./tests/api/test_create_account.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest



@pytest.mark.api
class TestCreateAccount:

    def test_create_valid_account(self, user_request: CreateUserRequest, api_manager: ApiManager):
        api_manager.user_steps.create_account(create_user_request=user_request)






================================================================================
FILE: ./tests/api/test_create_user.py
================================================================================
import pytest

from src.api.generators.random_data import RandomData
from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_user_request import CreateUserRequest


class RandomGenerator:
    pass


@pytest.mark.api
class TestCreateUser:
    @pytest.mark.parametrize('create_user_request', [RandomModelGenerator.generate(CreateUserRequest)])
    def test_create_valid_user(self, api_manager, create_user_request):
        api_manager.admin_steps.create_valid_user(create_user_request=create_user_request)





    @pytest.mark.parametrize(argnames="username,password, role, error_key, error_value",
                             argvalues=[
                                 ("", RandomData.get_valid_password(), "USER", 'username',
                                   'Username must be between 3 and 15 characters'),
                                 ("qwerty@",RandomData.get_valid_password(),"USER", 'username','Username must contain only letters, digits, dashes, underscores, and dots'),
                                 ("ka",RandomData.get_valid_password(),"USER", 'username','Username must be between 3 and 15 characters'),
                                 ("kakakakakakakaka", RandomData.get_valid_password(), "USER", 'username',
                                  'Username must be between 3 and 15 characters'),
                             ])
    def test_create_invalid_user(self,username: str,password: str, role: str, error_key: str, error_value:str, api_manager):
        create_user_request = CreateUserRequest(username=username, password=password, role=role)
        api_manager.admin_steps.create_invalid_user(create_user_request=create_user_request, error_key=error_key, error_value=error_value)


================================================================================
FILE: ./tests/api/test_fund_deposit.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.mark.api
class TestFundDeposit:
    #TODO: если укажем неправильный айди
    # проверить что удаляем пользователя
    # сравнение полей
    # негативные тест кейсы подумать еще
    def test_fund_deposit(self, user_request: CreateUserRequest, api_manager: ApiManager):
        response = api_manager.user_steps.fund_deposit(create_user_request=user_request)

================================================================================
FILE: ./tests/api/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/test_login_user.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.mark.api
class TestLogin:

    def test_login_user(self, user_request: CreateUserRequest, api_manager: ApiManager):
        api_manager.user_steps.login(user_request=user_request)


    def test_login_admin_user(self, api_manager: ApiManager, admin_user_request: CreateUserRequest):
        api_manager.user_steps.login(user_request=admin_user_request)


================================================================================
FILE: ./tests/api/test_update_customer_profile.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.requests.update_profile_request import UpdateProfileRequest


@pytest.mark.api
class TestUpdateCustomerProfile:

    @pytest.mark.parametrize('update_profile_request', [RandomModelGenerator.generate(UpdateProfileRequest)])
    def test_update_user_name(self, user_request: CreateUserRequest, api_manager: ApiManager, update_profile_request:UpdateProfileRequest):
        api_manager.user_steps.update_customer_profile(create_user_request=user_request, update_profile_request = update_profile_request)


    #TODO: воозращает plain/text - точно ли это ок. Сейчас считаем что ок
    @pytest.mark.parametrize(
        argnames="name, error_key, error_value",
        argvalues=[
            ("", "name", "Name must contain two words with letters only"),
            ("John", "name", "Name must contain two words with letters only"),
            ("John Doe Jr", "name", "Name must contain two words with letters only"),
            ("John1 Doe", "name", "Name must contain two words with letters only"),
            ("John Doe!", "name", "Name must contain two words with letters only"),
            ("Иван Иванов", "name", "Name must contain two words with letters only"),
            ("John  Doe", "name", "Name must contain two words with letters only"),
        ]
    )
    def test_update_user_name_invalid(
        self,
        user_request: CreateUserRequest,
        api_manager: ApiManager,
        name: str,
        error_key: str,
        error_value: str
    ):
        api_manager.user_steps.invalid_update_customer_profile(create_user_request=user_request, name = name, error_key = error_key, error_value = error_value)



================================================================================
FILE: ./src/__init__.py
================================================================================

================================================================================
FILE: ./src/api/__init__.py
================================================================================

================================================================================
FILE: ./src/api/classes/__init__.py
================================================================================

================================================================================
FILE: ./src/api/classes/api_manager.py
================================================================================
from src.api.steps.admin_steps import AdminSteps
from src.api.steps.user_steps import UserSteps


class ApiManager:
    def __init__(self, create_object: list):
        self.admin_steps = AdminSteps(create_object)
        self.user_steps = UserSteps(create_object)

================================================================================
FILE: ./src/api/specs/response_spec.py
================================================================================
from collections.abc import Callable
from http import HTTPStatus
from json import JSONDecodeError

from requests import Response


class ResponseSpecs:

    @staticmethod
    def request_returns_ok() -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.OK, response.text
        return check

    @staticmethod
    def entity_was_created() -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.CREATED, response.text
        return check

    @staticmethod
    def entity_was_deleted() -> Callable:
        def check(response: Response):
            assert response.status_code in (HTTPStatus.CREATED, HTTPStatus.OK), response.text
        return check


    @staticmethod
    def request_returns_bad_request(error_key: str, error_value: str) -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.BAD_REQUEST, response.text

            try:
                error_content = response.json().get(error_key)
            except JSONDecodeError:
                error_content = response.content
            error_text = str(error_content)

            assert error_value in error_text

        return check


================================================================================
FILE: ./src/api/specs/__init__.py
================================================================================

================================================================================
FILE: ./src/api/specs/request_spec.py
================================================================================
import logging

import requests

from src.api.configs.config import Config
from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.specs.response_spec import ResponseSpecs


class RequestSpecs:
    _BASE_URL = Config.get('backendUrl')

    @staticmethod
    def default_request_headers():
        return {
            'Content-Type': 'application/json',
            'Authorization': 'Basic YWRtaW46YWRtaW4=',
        }

    @staticmethod
    def unauth_spec():
        return RequestSpecs.default_request_headers()

    @staticmethod
    def admin_auth_spec():
        headers = RequestSpecs.default_request_headers()
        headers["authorization"] = "Basic YWRtaW46YWRtaW4="
        return headers

    @staticmethod
    def user_auth_spec(username: str, password: str):
        try:
            response = (
                CrudRequester(RequestSpecs.unauth_spec(), endpoint=Endpoint.LOGIN_USER, response_spec=ResponseSpecs.request_returns_ok())
                .post(LoginUserRequest(username=username, password=password)))

        except:
            logging.error(f"Authentification failed for {username} with status {response.status_code}")
            raise Exception(f"Authentification failed for {username} with status {response.status_code}")

        else:
            if response.status_code == 200:
                headers = RequestSpecs.default_request_headers()
                headers['Authorization'] = response.headers.get('Authorization')
                return headers



================================================================================
FILE: ./src/api/models/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/base_model.py
================================================================================
from pydantic import BaseModel as BM

class BaseModel(BM):...
================================================================================
FILE: ./src/api/models/responses/create_user_response.py
================================================================================
from typing import List, Dict, Any, Optional
from src.api.models.base_model import BaseModel
from src.api.models.responses.create_acoount_response import AccountResponse


class UserProfileResponse(BaseModel):
    id: int
    username:str|List[str]
    password: str
    name: Optional[str]
    role: str
    accounts: List[AccountResponse]

class CreateUserValidationErrorResponse(BaseModel):
    username: Optional[List[str]] = None
    password: Optional[List[str]] = None
    name: Optional[List[str]] = None
================================================================================
FILE: ./src/api/models/responses/create_acoount_response.py
================================================================================
from typing import List, Dict, Any, Optional
from src.api.models.base_model import BaseModel
from src.api.models.responses.transaction_response import TransactionResponse


class AccountResponse(BaseModel):
    id: int
    accountNumber:str
    balance: float
    transactions: List[TransactionResponse]
================================================================================
FILE: ./src/api/models/responses/transaction_response.py
================================================================================
from pydantic import BaseModel

class TransactionResponse(BaseModel):
    id: int
    amount: float
    type: str
    timestamp: str
    relatedAccountId: int
================================================================================
FILE: ./src/api/models/responses/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/responses/login_user_response.py
================================================================================
from typing import Optional

from src.api.models.base_model import BaseModel


class LoginUserResponse(BaseModel):
    username: str
    role: str
================================================================================
FILE: ./src/api/models/requests/login_user_request.py
================================================================================
from src.api.models.base_model import BaseModel


class LoginUserRequest(BaseModel):
    username:str
    password: str
================================================================================
FILE: ./src/api/models/requests/create_user_request.py
================================================================================
from typing import Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class CreateUserRequest(BaseModel):
    username: Annotated[str, GeneratingRule(regex=r"^[A-Za-z0-9]{3,15}$")]
    password: Annotated[str, GeneratingRule(regex=r"^[A-Z]{3}[a-z]{4}[0-9]{3}[$&]{2}$")]
    role: Annotated[str, GeneratingRule(regex=r"^USER$")]
================================================================================
FILE: ./src/api/models/requests/update_profile_request.py
================================================================================
from typing import Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class UpdateProfileRequest(BaseModel):
    name: Annotated[str, GeneratingRule(regex=r"^[A-Za-z]+ [A-Za-z]+$")]

================================================================================
FILE: ./src/api/models/requests/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/requests/fund_deposit_request.py
================================================================================
from src.api.models.base_model import BaseModel


class FundDepositRequest(BaseModel):
    id:int
    balance: float
================================================================================
FILE: ./src/api/models/comparison/model_assertions.py
================================================================================
from typing import Any

from src.api.models.comparison.model_comparator import ModelComparator
from src.api.models.comparison.model_comparison_configuration import ModelComparisonConfigLoader


class ModelAssertions:
    def __init__(self, request: Any, response: Any):
        self.request = request
        self.response = response

    def match(self) -> 'ModelAssertions':
        config_loader = ModelComparisonConfigLoader('model-comparison.properties')
        rule = config_loader.get_rule_for(self.request)
        if rule:
            result = ModelComparator.compare_fields(self.request, self.response, rule.field_mapping
                                                    )
            if not result.is_success():
                raise AssertionError(f'Model comparison failed with mismatches fields \n {result.mismatches}')
        else:
            raise AssertionError(f'Model comparison rule found for   \n {self.request.__class__.__name__}')
        return self
================================================================================
FILE: ./src/api/models/comparison/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/comparison/model_comparator.py
================================================================================
from typing import Any, Dict, List
from dataclasses import dataclass

#TODO: разобраться
@dataclass
class Mismatch:
    field_name: str
    expected: Any
    actual: Any

class ComparisonResult:
    def __init__(self, mismatches: List [Mismatch]):
        self._mismatches =  mismatches

    def is_success(self) -> bool:
        return not self.mismatches

    @property
    def mismatches(self)->List [Mismatch]:
        return self._mismatches

class ModelComparator:
    @staticmethod
    def compare_fields(request: Any, response: Any, field_mapping: Dict[str,str]):
        mismatches = []
        for request_field, response_field in field_mapping.items():
            request_value = ModelComparator._get_field_value(request, request_field)
            response_value = ModelComparator._get_field_value(response, response_field)
            if str(request_value)!=str(response_value):
                mismatches.append(Mismatch(f'{request_field} -> {response_field}', request_value, response_value))
        return ComparisonResult(mismatches)


    def _get_field_value(obj:Any, field_name: str):
        current_class = obj.__class__

        while current_class:
            if hasattr(obj, field_name):
                return getattr(obj, field_name)
            current_class = current_class.__base__
        raise AttributeError(f'Field {field_name} not found in class {obj.__class__.__name__}')

================================================================================
FILE: ./src/api/models/comparison/model_comparison_configuration.py
================================================================================
import os
from pathlib import Path
import configparser
from typing import Dict, Type, Optional


from typing import Dict

class ComparisonRule:
    def __init__(self, response_class_name: str, field_pairs: list[str]):
        self._response_class_name = response_class_name
        self._field_mapping: Dict[str, str] = {}

        for pair in field_pairs:
            parts = pair.split('=')
            if len(parts) == 2:
                self._field_mapping[parts[0].strip()] = parts[1].strip()
            else:
                key = pair.strip()
                self._field_mapping[key] = key

    @property
    def response_class_name(self) -> str:
        return self._response_class_name

    @property
    def field_mapping(self) -> Dict[str, str]:
        return self._field_mapping


class ModelComparisonConfigLoader:
    def __init__(self, config_file: str):
        self.rules : Dict[str, ComparisonRule]= {}
        self._load_config(config_file=config_file)

    def get_rule_for(self, request_class: Type) -> Optional[ComparisonRule]:
        return self.rules.get(type(request_class).__name__)

    def _load_config(self, config_file: str):
        config_path = Path(__file__).parents[4]/"resources" / f'{config_file}'
        if not os.path.exists(config_path):
            raise FileNotFoundError(f'Config file not found')

        config = configparser.ConfigParser()
        config.optionxform = str
        config.read(config_path)

        for key in config.defaults():
            value = config.defaults()[key]
            target = value.split(':')
            if len(target)!= 2:
                continue
            response_class = target[0].strip()
            field_list = [field.strip()  for field in target[1].split(',')]
            self.rules[key.strip()] = ComparisonRule(response_class, field_list)




================================================================================
FILE: ./src/api/requests/admin_user_requester.py
================================================================================
from http import HTTPStatus
from typing import Union

import requests

from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.responses.create_user_response import UserProfileResponse, CreateUserValidationErrorResponse
from src.api.requests.requester import Requester


class AdminUserRequester(Requester):

    def post(self, create_user_request:CreateUserRequest) -> Union[UserProfileResponse, None]:
        url = f"{self.base_url}/admin/users"
        response = requests.post(url=url, headers=self.headers, json=create_user_request.model_dump())
        self.response_spec(response)

        if response.status_code in [HTTPStatus.OK, HTTPStatus.CREATED]:
            return UserProfileResponse(**response.json())
        return None

    def delete(self, id: int):
        url = f"{self.base_url}/admin/users/{id}"
        response = requests.delete(url=url, headers=self.headers, )
        self.response_spec(response)
        return response


================================================================================
FILE: ./src/api/requests/create_account_requester.py
================================================================================
import requests

from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.requests.requester import Requester


class CreateAccountRequester(Requester):

    def post(self) -> UserProfileResponse:
        url = f"{self.base_url}/accounts"
        response = requests.post(url=url, headers=self.headers)
        self.response_spec(response)
        return UserProfileResponse(**response.json())


================================================================================
FILE: ./src/api/requests/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/requester.py
================================================================================
from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import Dict

from src.api.models.base_model import BaseModel


class Requester(ABC):
    def __init__(self, request_spec: Dict[str, str], response_spec: Callable):
        self.headers = request_spec.get('headers')
        self.base_url = request_spec.get('base_url', 'http://localhost:4111')
        self.response_spec = response_spec

    @abstractmethod
    def post(self, model:BaseModel|None):...
================================================================================
FILE: ./src/api/requests/login_user_requester.py
================================================================================
import requests

from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.models.responses.login_user_response import LoginUserResponse
from src.api.requests.requester import Requester



class LoginUserRequester(Requester):

    def post(self, login_user_request: LoginUserRequest) -> LoginUserResponse:
        url = f"{self.base_url}/auth/login"
        response = requests.post(url=url, headers=self.headers, json=login_user_request.model_dump())
        self.response_spec(response)
        return LoginUserResponse(**response.json())



================================================================================
FILE: ./src/api/requests/sceleton/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/endpoint.py
================================================================================
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from src.api.models.base_model import BaseModel
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.requests.fund_deposit_request import FundDepositRequest
from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.models.requests.update_profile_request import UpdateProfileRequest
from src.api.models.responses.create_acoount_response import AccountResponse
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.models.responses.login_user_response import LoginUserResponse


@dataclass(frozen=True)
class EndpointConfig:
    url:str
    request_model:Optional[BaseModel]
    response_model:Optional[BaseModel]

class Endpoint(Enum):
    ADMIN_CREATE_USER = EndpointConfig(url="/admin/users", request_model=CreateUserRequest, response_model=UserProfileResponse)
    ADMIN_DELETE_USER = EndpointConfig(url="/admin/users",request_model=None,response_model=None)
    LOGIN_USER = EndpointConfig(url="/auth/login", request_model=LoginUserRequest, response_model=LoginUserResponse)
    CREATE_ACCOUNT = EndpointConfig(url="/accounts", request_model=None, response_model=AccountResponse)
    FUND_DEPOSIT = EndpointConfig(url="/accounts/deposit", request_model=FundDepositRequest, response_model=AccountResponse)
    GET_CUSTOMER_PROFILE = EndpointConfig(url="/customer/profile", request_model=None, response_model=UserProfileResponse)
    UPDATE_CUSTOMER_PROFILE = EndpointConfig(url="/customer/profile", request_model=UpdateProfileRequest, response_model=None)
================================================================================
FILE: ./src/api/requests/sceleton/http_request.py
================================================================================
from collections.abc import Callable
from typing import Protocol, Dict

from src.api.requests.sceleton.endpoint import Endpoint


class HTTPRequest(Protocol):
    def __init__(self, request_spec: Dict[str,str], endpoint: Endpoint, response_spec: Callable):
        self.request_spec = request_spec
        self.endpoint = endpoint
        self.response_spec = response_spec
================================================================================
FILE: ./src/api/requests/sceleton/requesters/validated_crud_requester.py
================================================================================
from typing import TypeVar, Dict, Callable, Optional

from src.api.models.base_model import BaseModel
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.http_request import HTTPRequest
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester

T = TypeVar('T', bound=BaseModel)


class ValidatedCrudRequester(HTTPRequest):
    def __init__(self, request_spec: Dict[str, str], endpoint: Endpoint, response_spec: Callable):
        super().__init__(request_spec, endpoint, response_spec)
        self.crud_requester = CrudRequester(request_spec = request_spec, endpoint = endpoint, response_spec = response_spec)

    def post(self, model: Optional[T] = None):
        response = self.crud_requester.post(model= model)
        return self.endpoint.value.response_model.model_validate(response.json())

    def get(self):
        response = self.crud_requester.get()
        return self.endpoint.value.response_model.model_validate(response.json())

    def update(self,  model: T):
        response = self.crud_requester.update(model=model)
        return self.endpoint.value.response_model.model_validate(response.json())


================================================================================
FILE: ./src/api/requests/sceleton/requesters/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/requesters/crud_requester.py
================================================================================
from http import HTTPStatus
from typing import Protocol, Optional, Union, TypeVar

import requests
from requests import Response

from src.api.configs.config import Config
from src.api.models.base_model import BaseModel
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.requests.sceleton.http_request import HTTPRequest
from src.api.requests.sceleton.interfaces.crud_end_interface import CrudEndPointInterface

#дженерик, позволяющий сохранять строгую типизацию
T = TypeVar('T', bound=BaseModel)

class CrudRequester(HTTPRequest, CrudEndPointInterface):
    #TODO мы же наслодовались тут почему возвращаемы тип другой - не бейс модел
    def post(self, model: Optional[T]) -> Response:
        #TODO: optimize
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')


        body = model.model_dump() if model else ''
        response = requests.post(url=f'{server_url}{api_version_url}{self.endpoint.value.url}',
                                 headers=self.request_spec, json=body)
        self.response_spec(response)
        return response


    def get(self, model: Optional[BaseModel] = None, id : Optional[int] = None) -> BaseModel:

        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        response = requests.get(url=f'{server_url}{api_version_url}{self.endpoint.value.url}',
                                   headers=self.request_spec)
        self.response_spec(response)
        return response

    def update(self, model: Optional[BaseModel] = None) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}'
        body = model.model_dump() if model else {}

        response = requests.put(
            url=url,
            headers=self.request_spec,
            json=body
        )

        self.response_spec(response)
        return response

    #TODO мы же наслодовались тут почему возвращаемы тип другой - не бейс модел
    def delete(self, id: int) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        response = requests.delete(url=f'{server_url}{api_version_url}{self.endpoint.value.url}/{id}',
                                 headers=self.request_spec)
        self.response_spec(response)
        return response

================================================================================
FILE: ./src/api/requests/sceleton/interfaces/crud_end_interface.py
================================================================================
from typing import Protocol, Optional, Union

from src.api.models.base_model import BaseModel


class CrudEndPointInterface(Protocol):
    def post(self, model: BaseModel) -> BaseModel: ...

    def get(self, model: Optional[BaseModel] = None, id : Optional[int] = None) -> BaseModel: ...

    def update(self, model: Optional[BaseModel] = None, id: Optional[int] = None) -> BaseModel: ...

    def delete(self, id: int) -> Union[BaseModel, bool]: ...

================================================================================
FILE: ./src/api/steps/__init__.py
================================================================================

================================================================================
FILE: ./src/api/steps/admin_steps.py
================================================================================
from typing import Union

from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.comparison.model_assertions import ModelAssertions
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.requests.sceleton.requesters.validated_crud_requester import ValidatedCrudRequester
from src.api.specs.request_spec import RequestSpecs
from src.api.specs.response_spec import ResponseSpecs
from src.api.steps.base_steps import BaseSteps





class AdminSteps(BaseSteps):

    def create_valid_user(self, create_user_request:CreateUserRequest = RandomModelGenerator.generate(CreateUserRequest)) -> Union[UserProfileResponse, None]:


        create_user_response: UserProfileResponse = ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.ADMIN_CREATE_USER,
            response_spec=ResponseSpecs.entity_was_created()
        ).post(create_user_request)


        ModelAssertions(create_user_request,create_user_response).match()

        self.created_objects.append(create_user_response)

        return create_user_response

    def create_invalid_user(self, create_user_request:CreateUserRequest, error_key, error_value):

        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.ADMIN_CREATE_USER,
            response_spec=ResponseSpecs.request_returns_bad_request(error_key,error_value)
        ).post(create_user_request)


    def delete_user(self,user_id: int):

        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.ADMIN_DELETE_USER,
            response_spec=ResponseSpecs.entity_was_deleted()
        ).delete(user_id)





================================================================================
FILE: ./src/api/steps/user_steps.py
================================================================================
from typing import Dict

from src.api.models.comparison.model_assertions import ModelAssertions
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.requests.fund_deposit_request import FundDepositRequest
from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.models.requests.update_profile_request import UpdateProfileRequest
from src.api.models.responses.create_acoount_response import AccountResponse
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.models.responses.login_user_response import LoginUserResponse
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.requests.sceleton.requesters.validated_crud_requester import ValidatedCrudRequester
from src.api.specs.request_spec import RequestSpecs
from src.api.specs.response_spec import ResponseSpecs
from src.api.steps.base_steps import BaseSteps


class UserSteps(BaseSteps):
    # --- helpers ---
    def _auth_headers(self, user: CreateUserRequest) -> Dict[str, str]:
        return RequestSpecs.user_auth_spec(user.username, user.password)

    def _get_profile(self, headers: Dict[str, str]) -> UserProfileResponse:
        return ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.GET_CUSTOMER_PROFILE,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    # --- steps ---
    def login(self, user_request: CreateUserRequest) -> LoginUserResponse:
        login_request = LoginUserRequest(username=user_request.username, password=user_request.password)

        login_user_response: LoginUserResponse = ValidatedCrudRequester(
            request_spec=RequestSpecs.unauth_spec(),
            endpoint=Endpoint.LOGIN_USER,
            response_spec=ResponseSpecs.request_returns_ok()
        ).post(login_request)

        ModelAssertions(login_request, login_user_response).match()

        self.created_objects.append(login_user_response)
        return login_user_response

    def create_account(self, create_user_request: CreateUserRequest) -> AccountResponse:
        headers = self._auth_headers(create_user_request)

        create_account_response: AccountResponse = ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.CREATE_ACCOUNT,
            response_spec=ResponseSpecs.entity_was_created()
        ).post()

        assert create_account_response.balance == 0.0
        assert create_account_response.transactions == []
        assert create_account_response.id

        return create_account_response

    def fund_deposit(self, create_user_request: CreateUserRequest) -> AccountResponse:
        headers = self._auth_headers(create_user_request)

        create_account_response: AccountResponse = ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.CREATE_ACCOUNT,
            response_spec=ResponseSpecs.entity_was_created()
        ).post()

        assert create_account_response.balance == 0.0
        assert create_account_response.transactions == []
        assert create_account_response.id

        fund_deposit_request = FundDepositRequest(id=create_account_response.id, balance=100.00)

        deposit_response: AccountResponse = ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.FUND_DEPOSIT,
            response_spec=ResponseSpecs.request_returns_ok()
        ).post(fund_deposit_request)

        return deposit_response

    def get_customer_profile(self, create_user_request: CreateUserRequest) -> UserProfileResponse:
        headers = self._auth_headers(create_user_request)
        return self._get_profile(headers)

    def update_customer_profile(
        self,
        create_user_request: CreateUserRequest, update_profile_request: UpdateProfileRequest
    ) -> UserProfileResponse:

        headers = self._auth_headers(create_user_request)

        profile_response_before_update = self._get_profile(headers)
        assert profile_response_before_update.name is None

        CrudRequester(
            request_spec=headers,
            endpoint=Endpoint.UPDATE_CUSTOMER_PROFILE,
            response_spec=ResponseSpecs.request_returns_ok()
        ).update(update_profile_request)

        profile_response_after_update = self._get_profile(headers)
        assert profile_response_after_update.name == update_profile_request.name

        return profile_response_after_update

    def invalid_update_customer_profile(
        self,
        create_user_request: CreateUserRequest, name: str, error_key: str, error_value: str
    ):

        update_profile_request = UpdateProfileRequest(name= name)

        CrudRequester(
            request_spec=RequestSpecs.user_auth_spec(create_user_request.username, create_user_request.password),
            endpoint=Endpoint.UPDATE_CUSTOMER_PROFILE,
            response_spec=ResponseSpecs.request_returns_bad_request(error_key=error_key, error_value=error_value)
        ).update(update_profile_request)
================================================================================
FILE: ./src/api/steps/base_steps.py
================================================================================
from typing import List, Any


class BaseSteps:
    def __init__(self, created_objects: List[Any]):
        self.created_objects = created_objects
================================================================================
FILE: ./src/api/configs/config.py
================================================================================
import configparser
from pathlib import Path
from typing import Any


class Config:
    config = None
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Config, cls).__new__(cls)
            config_path = Path(__file__).parents[3]/"resources"/"config.properties"

            cls.config = configparser.ConfigParser()
            cls.config.read(config_path)
        return cls._instance

    @staticmethod
    def get(key:str, default_value: Any = None):
        return Config().config["DEFAULT"].get(key, fallback=default_value)



================================================================================
FILE: ./src/api/configs/__init__.py
================================================================================

================================================================================
FILE: ./src/api/fixtures/api_fixtures.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager


@pytest.fixture
def api_manager(created_objects) -> ApiManager:
    return ApiManager(created_objects)
================================================================================
FILE: ./src/api/fixtures/user_fixtures.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.fixture
def user_request(api_manager: ApiManager) -> CreateUserRequest:
    user_data: CreateUserRequest = RandomModelGenerator.generate(CreateUserRequest)
    api_manager.admin_steps.create_valid_user(user_data)
    return user_data


@pytest.fixture
def admin_user_request() -> CreateUserRequest:
    return CreateUserRequest(username="admin", password="admin", role='ADMIN')
================================================================================
FILE: ./src/api/fixtures/objects_fixture.py
================================================================================
import logging

import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.responses.create_user_response import UserProfileResponse


def cleanup_object(objects: list):
    api_manager = ApiManager(objects)
    for obj in objects:
        if isinstance(obj, UserProfileResponse):
            api_manager.admin_steps.delete_user(obj.id)
        else:
            logging.warning(f'Object type: {type(obj)} is not deleted')


@pytest.fixture
def created_objects():
    objects: list = []
    yield objects
    cleanup_object(objects)
================================================================================
FILE: ./src/api/generators/random_model_generator.py
================================================================================
import random
import uuid
from datetime import datetime, timedelta
from typing import get_type_hints, Any, get_origin, Annotated, get_args

import rstr

from src.api.generators.generating_rule import GeneratingRule
class RandomModelGenerator:
    @staticmethod
    def generate(cls: type) -> Any:
        type_hints = get_type_hints(cls, include_extras=True)
        init_data = {}

        for field_name, annotated_type in type_hints.items():
            rule = None
            actual_type = annotated_type

            if get_origin(annotated_type) is Annotated:
                actual_type, *annotations = get_args(annotated_type)
                for ann in annotations:
                    if isinstance(ann, GeneratingRule):
                        rule = ann

            if rule:
                value = RandomModelGenerator._generate_from_regex(
                    rule.regex,
                    actual_type
                )
            else:
                value = RandomModelGenerator._generate_value(actual_type)
            init_data[field_name] = value
        return cls(**init_data)


    @staticmethod
    def _generate_from_regex(regex: str, field_type: type) -> Any:
        generated = rstr.xeger(regex)

        if field_type is int:
            return int(generated)

        if field_type is float:
            return float(generated)

        return generated

    @staticmethod
    def _generate_value(field_type: type) -> Any:
        if field_type is str:
            return str(uuid.uuid4())[:8]
        elif field_type is int:
            return random.randint(0, 1000)
        elif field_type is float:
            return round(random.uniform(0, 100.0), 2)
        elif field_type is bool:
            return random.choice([True, False])
        elif field_type is datetime:
            return datetime.now() - timedelta(seconds=random.randint(0, 100000))
        elif field_type is list:
            return [str(uuid.uuid4())[:5] for _ in range(random.randint(3, 10))]
        elif isinstance(field_type, type):
            return RandomModelGenerator.generate(field_type)
        return



================================================================================
FILE: ./src/api/generators/__init__.py
================================================================================

================================================================================
FILE: ./src/api/generators/random_data.py
================================================================================
import string

from faker import Faker
import random

#TODO: почему это костыль?
class RandomData:
    faker = Faker()

    @staticmethod
    def get_valid_username() -> str:
        length = random.randint(3, 15)
        return "".join(
            RandomData.faker.random_letters(length=length))

    @staticmethod
    def get_valid_password() -> str:
        upper = random.sample(string.ascii_uppercase, 3)
        lower = random.sample(string.ascii_lowercase, 3)
        digits = random.sample(string.digits, 3)
        special = random.choice("!@#$%")

        pwd = upper + lower + digits + [special]
        random.shuffle(pwd)
        return "".join(pwd)
================================================================================
FILE: ./src/api/generators/generating_rule.py
================================================================================
from dataclasses import dataclass

@dataclass
class GeneratingRule:
    regex: str