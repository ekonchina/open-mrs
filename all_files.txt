
================================================================================
FILE: ./all_files.txt
================================================================================

================================================================================
FILE: ./pytest.ini
================================================================================
[pytest]

markers =
    api: API autotests
    debud: Debud

================================================================================
FILE: ./requirements.txt
================================================================================
pytest
requests
pydantic
faker
rstr
================================================================================
FILE: ./.gitignore
================================================================================
# PyCharm / IntelliJ IDEA
.idea/
*.iml

# Python
__pycache__/
*.py[cod]
*$py.class

# Virtual environments
.venv/
venv/
env/

# Pytest
.pytest_cache/

# Allure
allure-results/
allure-report/

# Coverage / reports
.coverage
htmlcov/
coverage.xml

# Logs
*.log

# OS
.DS_Store
Thumbs.db

# Build / dist
build/
dist/
*.egg-info/

# Environment variables
.env
.env.*

# Mypy / type checking
.mypy_cache/
.pyre/

# Jupyter
.ipynb_checkpoints/


================================================================================
FILE: ./collect_data.py
================================================================================
import os

ROOT_DIR = "."          # корневая папка
OUTPUT_FILE = "all_files.txt"

# Директории, которые нужно исключить
EXCLUDED_DIRS = {
    ".venv",
    ".git",
    "node_modules",
    "__pycache__",
    ".idea"
}

def is_binary(file_path, blocksize=512):
    try:
        with open(file_path, "rb") as f:
            return b"\0" in f.read(blocksize)
    except Exception:
        return True

with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
    for root, dirs, files in os.walk(ROOT_DIR):
        # Исключаем директории на лету
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        for file in files:
            file_path = os.path.join(root, file)

            # Пропускаем бинарные файлы
            if is_binary(file_path):
                continue

            out.write(f"\n{'='*80}\n")
            out.write(f"FILE: {file_path}\n")
            out.write(f"{'='*80}\n")

            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    out.write(f.read())
            except Exception as e:
                out.write(f"\n[ERROR READING FILE: {e}]\n")

print(f"Готово! Исключены .venv, .git, node_modules, __pycache__. Результат: {OUTPUT_FILE}")

================================================================================
FILE: ./.pytest_cache/CACHEDIR.TAG
================================================================================
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

================================================================================
FILE: ./.pytest_cache/README.md
================================================================================
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

================================================================================
FILE: ./.pytest_cache/.gitignore
================================================================================
# Created by pytest automatically.
*

================================================================================
FILE: ./.pytest_cache/v/cache/nodeids
================================================================================
[
  "help_requests/test_create_person.py::test_create_person_full_validation[payload0-expected0]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload1-expected1]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload2-expected2]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload3-expected3]",
  "help_requests/test_create_person.py::test_create_person_full_validation[payload4-expected4]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload0]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload1]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload2]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload3]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload4]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload5]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload6]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload7]",
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload8]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload0-expected_check0]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload1-expected_check1]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload2-expected_check2]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload3-expected_check3]",
  "help_requests/test_create_person.py::test_create_person_success_variants[payload4-expected_check4]",
  "help_requests/test_create_person.py::test_create_person_success_with_correct_validation[payload0-expected0]",
  "help_requests/test_create_person.py::test_create_person_success_with_correct_validation[payload1-expected1]",
  "help_requests/test_create_person.py::test_create_person_success_with_correct_validation[payload2-expected2]",
  "tests/api/open_msr/test_create_patient_from_existing_person.py::test_create_patient_from_existing_person",
  "tests/api/open_msr/test_create_person.py::test_create_person",
  "tests/api/open_msr/test_create_person.py::test_create_person_full_validation[create_person_request0]",
  "tests/api/open_msr/test_create_person.py::test_create_person_full_validation[create_person_request1]",
  "tests/api/open_msr/test_create_person.py::test_create_person_full_validation[create_person_request2]",
  "tests/api/open_msr/test_create_person.py::test_create_person_generated",
  "tests/api/open_msr/test_get_locations.py::test_get_locations",
  "tests/api/open_msr/test_get_patient_identifier_types.py::TestPatientIdentifierTyped::test_patient_identifier_types",
  "tests/api/open_msr/test_get_roles.py::TestGetRoles::test_get_roles",
  "tests/api/test_create_patient_from_existing_person.py::test_create_patient_from_existing_person_generated",
  "tests/test_check.py::TestGetRoles::test_get_roles"
]
================================================================================
FILE: ./.pytest_cache/v/cache/lastfailed
================================================================================
{
  "tests/test_check.py::TestGetRoles::test_get_roles": true,
  "tests/test_check.py": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload0-expected_check0]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload1-expected_check1]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload2-expected_check2]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload3-expected_check3]": true,
  "help_requests/test_create_person.py::test_create_person_success_variants[payload4-expected_check4]": true,
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload5]": true,
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload2]": true,
  "help_requests/test_create_person.py::test_create_person_negative_validation[payload4]": true,
  "tests/api/test_create_patient_from_existing_person.py::test_create_patient_from_existing_person_generated": true,
  "tests/api/open_msr/test_create_person.py::test_create_person_generated": true
}
================================================================================
FILE: ./resources/model-comparison.properties
================================================================================
[DEFAULT]
CreateUserRequest=CreateUserResponse:username = username,role=role
LoginUserRequest=LoginUserResponse:username = username
CreatePersonRequest=PersonFullResponse:gender=gender,names[0].givenName=names[0].givenName,names[0].familyName=names[0].familyName

================================================================================
FILE: ./resources/config.properties
================================================================================
[DEFAULT]
server = http://localhost/openmrs/ws/rest
api_version = /v1
================================================================================
FILE: ./tests/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/conftest.py
================================================================================
import logging

import pytest

from src.api.fixtures.api_fixtures import *
from src.api.fixtures.user_fixtures import *
from src.api.fixtures.objects_fixture import *
from src.api.models.responses.create_patient_response import PatientCreateResponse
from src.api.models.responses.create_person_response import CreatPersonResponse

from src.api.models.responses.create_user_response import UserProfileResponse


def cleanup_object(objects: list):
    api_manager = ApiManager(objects)
    for obj in objects:
        if isinstance(obj, UserProfileResponse):
            api_manager.admin_steps.delete_user(obj.id)
        elif isinstance(obj, CreatPersonResponse):
            api_manager.admin_steps.delete_person(obj.uuid, purge=True)
        elif isinstance(obj, PatientCreateResponse):
            api_manager.admin_steps.delete_patient(obj.uuid, purge=True)
        else:
            logging.warning(f'Object type: {type(obj)} is not deleted')


@pytest.fixture
def created_objects():
    objects: list = []
    yield objects
    cleanup_object(objects)





================================================================================
FILE: ./tests/api/test_get_customer_profile.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.mark.api
class TestLogin:

    #сравнение полей

    def test_get_customer_profile(self, user_request: CreateUserRequest, api_manager: ApiManager):
        api_manager.user_steps.get_customer_profile(create_user_request=user_request)


================================================================================
FILE: ./tests/api/test_create_account.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest



@pytest.mark.api
class TestCreateAccount:

    def test_create_valid_account(self, user_request: CreateUserRequest, api_manager: ApiManager):
        api_manager.user_steps.create_account(create_user_request=user_request)






================================================================================
FILE: ./tests/api/test_create_user.py
================================================================================
import pytest

from src.api.generators.random_data import RandomData
from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_user_request import CreateUserRequest


class RandomGenerator:
    pass


@pytest.mark.api
class TestCreateUser:
    @pytest.mark.parametrize('create_user_request', [RandomModelGenerator.generate(CreateUserRequest)])
    def test_create_valid_user(self, api_manager, create_user_request):
        api_manager.admin_steps.create_valid_user(create_user_request=create_user_request)





    @pytest.mark.parametrize(argnames="username,password, role, error_key, error_value",
                             argvalues=[
                                 ("", RandomData.get_valid_password(), "USER", 'username',
                                   'Username must be between 3 and 15 characters'),
                                 ("qwerty@",RandomData.get_valid_password(),"USER", 'username','Username must contain only letters, digits, dashes, underscores, and dots'),
                                 ("ka",RandomData.get_valid_password(),"USER", 'username','Username must be between 3 and 15 characters'),
                                 ("kakakakakakakaka", RandomData.get_valid_password(), "USER", 'username',
                                  'Username must be between 3 and 15 characters'),
                             ])
    def test_create_invalid_user(self,username: str,password: str, role: str, error_key: str, error_value:str, api_manager):
        create_user_request = CreateUserRequest(username=username, password=password, role=role)
        api_manager.admin_steps.create_invalid_user(create_user_request=create_user_request, error_key=error_key, error_value=error_value)


================================================================================
FILE: ./tests/api/test_fund_deposit.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.mark.api
class TestFundDeposit:
    #TODO: если укажем неправильный айди
    # проверить что удаляем пользователя
    # сравнение полей
    # негативные тест кейсы подумать еще
    def test_fund_deposit(self, user_request: CreateUserRequest, api_manager: ApiManager):
        response = api_manager.user_steps.fund_deposit(create_user_request=user_request)

================================================================================
FILE: ./tests/api/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/test_login_user.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.mark.api
class TestLogin:

    def test_login_user(self, user_request: CreateUserRequest, api_manager: ApiManager):
        api_manager.user_steps.login(user_request=user_request)


    def test_login_admin_user(self, api_manager: ApiManager, admin_user_request: CreateUserRequest):
        api_manager.user_steps.login(user_request=admin_user_request)


================================================================================
FILE: ./tests/api/test_update_customer_profile.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.requests.update_profile_request import UpdateProfileRequest


@pytest.mark.api
class TestUpdateCustomerProfile:

    @pytest.mark.parametrize('update_profile_request', [RandomModelGenerator.generate(UpdateProfileRequest)])
    def test_update_user_name(self, user_request: CreateUserRequest, api_manager: ApiManager, update_profile_request:UpdateProfileRequest):
        api_manager.user_steps.update_customer_profile(create_user_request=user_request, update_profile_request = update_profile_request)


    #TODO: воозращает plain/text - точно ли это ок. Сейчас считаем что ок
    @pytest.mark.parametrize(
        argnames="name, error_key, error_value",
        argvalues=[
            ("", "name", "Name must contain two words with letters only"),
            ("John", "name", "Name must contain two words with letters only"),
            ("John Doe Jr", "name", "Name must contain two words with letters only"),
            ("John1 Doe", "name", "Name must contain two words with letters only"),
            ("John Doe!", "name", "Name must contain two words with letters only"),
            ("Иван Иванов", "name", "Name must contain two words with letters only"),
            ("John  Doe", "name", "Name must contain two words with letters only"),
        ]
    )
    def test_update_user_name_invalid(
        self,
        user_request: CreateUserRequest,
        api_manager: ApiManager,
        name: str,
        error_key: str,
        error_value: str
    ):
        api_manager.user_steps.invalid_update_customer_profile(create_user_request=user_request, name = name, error_key = error_key, error_value = error_value)



================================================================================
FILE: ./tests/api/open_msr/test_get_locations.py
================================================================================
import pytest


@pytest.mark.api
def test_get_locations(api_manager):
    locations = api_manager.admin_steps.get_locations()

    assert locations.results
    assert locations.results[0].uuid
    assert locations.results[0].display

================================================================================
FILE: ./tests/api/open_msr/__init__.py
================================================================================

================================================================================
FILE: ./tests/api/open_msr/test_create_patient_from_existing_person.py
================================================================================
import pytest

from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_person_request import CreatePersonRequest
from src.api.models.requests.create_patient_from_person_request import (
    CreatePatientFromPersonRequest,
    PatientIdentifierRequest,
)


@pytest.mark.api
def test_create_patient_from_existing_person(api_manager):
    # 1) Создаём person
    create_person_request_data = RandomModelGenerator.generate(CreatePersonRequest)
    created_person = api_manager.admin_steps.create_person(create_person_request_data)

    assert created_person.uuid
    assert created_person.voided is False

    # 2) Берём валидные справочники с сервера
    types = api_manager.admin_steps.get_patient_identifier_types()
    assert types.results and types.results[0].uuid
    identifier_type_uuid = types.results[0].uuid

    locations = api_manager.admin_steps.get_locations()
    assert locations.results and locations.results[0].uuid
    location_uuid = locations.results[0].uuid

    # 3) Собираем request на patient из существующего person
    identifier = RandomModelGenerator.generate(PatientIdentifierRequest)
    identifier.identifierType = identifier_type_uuid
    identifier.location = location_uuid
    identifier.preferred = True

    create_patient_req = CreatePatientFromPersonRequest(
        person=created_person.uuid,
        identifiers=[identifier],
    )

    # 4) Создаём patient
    created_patient = api_manager.admin_steps.create_patient_from_person(create_patient_req)

    # 5) Ассерты “минимально железные”
    assert created_patient.uuid
    assert created_patient.display

    # identifiers в ответе могут быть не всегда/зависит от rep, но если есть — проверим
    if created_patient.identifiers:
        assert any(i.uuid for i in created_patient.identifiers)

================================================================================
FILE: ./tests/api/open_msr/test_get_roles.py
================================================================================
import pytest


@pytest.mark.api
class TestGetRoles:
    def test_get_roles(self, api_manager):
        roles = api_manager.admin_steps.get_roles()
        assert roles.results
================================================================================
FILE: ./tests/api/open_msr/test_get_patient_identifier_types.py
================================================================================
import pytest


@pytest.mark.api
class TestPatientIdentifierTyped:
    def test_patient_identifier_types(self, api_manager):
        types = api_manager.admin_steps.get_patient_identifier_types()
        assert types.results
================================================================================
FILE: ./tests/api/open_msr/test_create_person.py
================================================================================
import pytest


from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_person_request import CreatePersonRequest

@pytest.mark.api
def test_create_person(api_manager):
    req = RandomModelGenerator.generate(CreatePersonRequest)
    created = api_manager.admin_steps.create_person(req)

    #TODO: убрать куда-нибудь
    assert created.uuid
    assert created.voided is False
    assert created.preferredName.uuid
    full = api_manager.admin_steps.get_person_full(created.uuid)

    # TODO: убрать куда-нибудь
    assert full.uuid == created.uuid


================================================================================
FILE: ./src/__init__.py
================================================================================

================================================================================
FILE: ./src/api/__init__.py
================================================================================

================================================================================
FILE: ./src/api/classes/__init__.py
================================================================================

================================================================================
FILE: ./src/api/classes/api_manager.py
================================================================================
from src.api.steps.admin_steps import AdminSteps
from src.api.steps.user_steps import UserSteps


class ApiManager:
    def __init__(self, create_object: list):
        self.admin_steps = AdminSteps(create_object)
        self.user_steps = UserSteps(create_object)

================================================================================
FILE: ./src/api/specs/response_spec.py
================================================================================
from collections.abc import Callable
from http import HTTPStatus
from json import JSONDecodeError

from requests import Response


class ResponseSpecs:

    @staticmethod
    def request_returns_ok() -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.OK, response.text
        return check

    @staticmethod
    def entity_was_created() -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.CREATED, response.text
        return check

    @staticmethod
    def entity_was_deleted() -> Callable:
        def check(response: Response):
            assert response.status_code in (HTTPStatus.CREATED, HTTPStatus.OK, HTTPStatus.NO_CONTENT), response.text
        return check


    @staticmethod
    def request_returns_bad_request(error_key: str, error_value: str) -> Callable:
        def check(response: Response):
            assert response.status_code == HTTPStatus.BAD_REQUEST, response.text

            try:
                error_content = response.json().get(error_key)
            except JSONDecodeError:
                error_content = response.content
            error_text = str(error_content)

            assert error_value in error_text

        return check


================================================================================
FILE: ./src/api/specs/__init__.py
================================================================================

================================================================================
FILE: ./src/api/specs/request_spec.py
================================================================================
import base64
import logging

import requests

from src.api.configs.config import Config
from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.specs.response_spec import ResponseSpecs


class RequestSpecs:

    @staticmethod
    def default_request_headers():
        return {
            'Content-Type': 'application/json',
            'Authorization': 'Basic YWRtaW46YWRtaW4=',
        }

    @staticmethod
    def unauth_spec():
        return RequestSpecs.default_request_headers()

    @staticmethod
    def admin_auth_spec():
        raw = "admin:Admin123"
        token = base64.b64encode(raw.encode()).decode()
        headers = RequestSpecs.default_request_headers()
        headers["authorization"] = f"Basic {token}"
        return headers

    @staticmethod
    def user_auth_spec(username: str, password: str):
        try:
            response = (
                CrudRequester(RequestSpecs.unauth_spec(), endpoint=Endpoint.LOGIN_USER, response_spec=ResponseSpecs.request_returns_ok())
                .post(LoginUserRequest(username=username, password=password)))

        except:
            logging.error(f"Authentification failed for {username} with status {response.status_code}")
            raise Exception(f"Authentification failed for {username} with status {response.status_code}")

        else:
            if response.status_code == 200:
                headers = RequestSpecs.default_request_headers()
                headers['Authorization'] = response.headers.get('Authorization')
                return headers



================================================================================
FILE: ./src/api/models/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/base_model.py
================================================================================
from pydantic import BaseModel as BM

class BaseModel(BM):...
================================================================================
FILE: ./src/api/models/responses/get_location_response.py
================================================================================
from typing import List, Optional
from src.api.models.base_model import BaseModel


class LocationLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str]


class LocationResult(BaseModel):
    uuid: str
    display: str
    links: List[LocationLink]


class LocationListLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str]


class LocationListResponse(BaseModel):
    results: List[LocationResult]
    links: Optional[List[LocationListLink]] = None

================================================================================
FILE: ./src/api/models/responses/create_user_response.py
================================================================================
from typing import List, Dict, Any, Optional
from src.api.models.base_model import BaseModel
from src.api.models.responses.create_acoount_response import AccountResponse


class UserProfileResponse(BaseModel):
    id: int
    username:str|List[str]
    password: str
    name: Optional[str]
    role: str
    accounts: List[AccountResponse]

class CreateUserValidationErrorResponse(BaseModel):
    username: Optional[List[str]] = None
    password: Optional[List[str]] = None
    name: Optional[List[str]] = None
================================================================================
FILE: ./src/api/models/responses/create_acoount_response.py
================================================================================
from typing import List, Dict, Any, Optional
from src.api.models.base_model import BaseModel
from src.api.models.responses.transaction_response import TransactionResponse


class AccountResponse(BaseModel):
    id: int
    accountNumber:str
    balance: float
    transactions: List[TransactionResponse]
================================================================================
FILE: ./src/api/models/responses/patient_identifier_type_response.py
================================================================================
from typing import List
from src.api.models.base_model import BaseModel


class PatientIdentifierTypeLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: str


class PatientIdentifierTypeResult(BaseModel):
    uuid: str
    display: str
    links: List[PatientIdentifierTypeLink]


class PatientIdentifierTypeListResponse(BaseModel):
    results: List[PatientIdentifierTypeResult]

================================================================================
FILE: ./src/api/models/responses/transaction_response.py
================================================================================
from pydantic import BaseModel

class TransactionResponse(BaseModel):
    id: int
    amount: float
    type: str
    timestamp: str
    relatedAccountId: int
================================================================================
FILE: ./src/api/models/responses/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/responses/login_user_response.py
================================================================================
from typing import Optional

from src.api.models.base_model import BaseModel


class LoginUserResponse(BaseModel):
    username: str
    role: str
================================================================================
FILE: ./src/api/models/responses/create_person_response.py
================================================================================
from typing import List, Optional, Any
from src.api.models.base_model import BaseModel

#TODO: понять с full
class Link(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str] = None


class PreferredName(BaseModel):
    uuid: str
    display: Optional[str] = None
    links: Optional[List[Link]] = None


class CreatPersonResponse(BaseModel):
    uuid: str
    display: str
    gender: str
    voided: bool
    preferredName: PreferredName
    links: List[Link]
    resourceVersion: Optional[str] = None


# Для v=full удобнее взять “мягкую” модель (т.к. полей много и они могут отличаться)
class PersonFullResponse(BaseModel):
    uuid: str
    display: str
    gender: str
    voided: bool

    # поля, которые точно встречаются в full
    names: List[Any]
    attributes: List[Any]
    birthdateEstimated: bool
    dead: bool
    deathdateEstimated: bool

    preferredName: Any
    links: List[Link]

================================================================================
FILE: ./src/api/models/responses/get_roles_response.py
================================================================================
from typing import List
from src.api.models.base_model import BaseModel


class RoleLink(BaseModel):
    rel: str
    uri: str
    resourceAlias: str


class RoleResult(BaseModel):
    uuid: str
    display: str
    links: List[RoleLink]


class RoleListResponse(BaseModel):
    results: List[RoleResult]

================================================================================
FILE: ./src/api/models/responses/create_patient_response.py
================================================================================
from typing import List, Optional, Any
from src.api.models.base_model import BaseModel


class Link(BaseModel):
    rel: str
    uri: str
    resourceAlias: Optional[str] = None


class PatientIdentifierResponse(BaseModel):
    uuid: str
    display: Optional[str] = None
    identifier: Optional[str] = None
    preferred: Optional[bool] = None
    # OpenMRS часто возвращает identifierType/location как объект или ссылку (разные reps),
    # поэтому делаем мягко:
    identifierType: Optional[Any] = None
    location: Optional[Any] = None


class PatientCreateResponse(BaseModel):
    uuid: str
    display: str
    identifiers: Optional[List[PatientIdentifierResponse]] = None
    links: Optional[List[Link]] = None

================================================================================
FILE: ./src/api/models/requests/login_user_request.py
================================================================================
from src.api.models.base_model import BaseModel


class LoginUserRequest(BaseModel):
    username:str
    password: str
================================================================================
FILE: ./src/api/models/requests/create_user_request.py
================================================================================
from typing import Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class CreateUserRequest(BaseModel):
    username: Annotated[str, GeneratingRule(regex=r"^[A-Za-z0-9]{3,15}$")]
    password: Annotated[str, GeneratingRule(regex=r"^[A-Z]{3}[a-z]{4}[0-9]{3}[$&]{2}$")]
    role: Annotated[str, GeneratingRule(regex=r"^USER$")]
================================================================================
FILE: ./src/api/models/requests/update_profile_request.py
================================================================================
from typing import Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class UpdateProfileRequest(BaseModel):
    name: Annotated[str, GeneratingRule(regex=r"^[A-Za-z]+ [A-Za-z]+$")]

================================================================================
FILE: ./src/api/models/requests/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/requests/fund_deposit_request.py
================================================================================
from src.api.models.base_model import BaseModel


class FundDepositRequest(BaseModel):
    id:int
    balance: float
================================================================================
FILE: ./src/api/models/requests/create_patient_from_person_request.py
================================================================================
from typing import List, Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel


class PatientIdentifierRequest(BaseModel):
    # В OpenMRS identifier — произвольная строка, но пусть будет "безопасная" генерация
    identifier: Annotated[str, GeneratingRule(regex=r"^[A-Za-z0-9]{5,12}$")]
    identifierType: str  # uuid
    location: str        # uuid
    preferred: bool = False


class CreatePatientFromPersonRequest(BaseModel):
    person: str  # uuid существующей Person
    identifiers: List[PatientIdentifierRequest]

================================================================================
FILE: ./src/api/models/requests/create_person_request.py
================================================================================
from typing import List, Optional, Annotated

from src.api.generators.generating_rule import GeneratingRule
from src.api.models.base_model import BaseModel

#TODO: Тут генерировать данные
class PersonNameRequest(BaseModel):
    # по доке: givenName, familyName :contentReference[oaicite:1]{index=1}
    givenName: Annotated[str, GeneratingRule(regex=r"^[A-Z][a-z]{2,12}$")]
    familyName: Annotated[str, GeneratingRule(regex=r"^[A-Z][a-z]{2,16}$")]


class PersonAddressRequest(BaseModel):
    # по доке (пример): address1, cityVillage, country, postalCode :contentReference[oaicite:2]{index=2}
    address1: Annotated[str, GeneratingRule(regex=r"^[A-Za-z0-9 ,.-]{5,60}$")]
    cityVillage: Annotated[str, GeneratingRule(regex=r"^[A-Za-z .-]{2,40}$")]
    country: Annotated[str, GeneratingRule(regex=r"^[A-Za-z .-]{2,40}$")]
    postalCode: Annotated[str, GeneratingRule(regex=r"^[0-9]{4,10}$")]


class CreatePersonRequest(BaseModel):
    # по доке: names[] :contentReference[oaicite:3]{index=3}
    names: List[PersonNameRequest]

    # по доке: gender "M" (в примере) :contentReference[oaicite:4]{index=4}
    gender: Annotated[str, GeneratingRule(regex=r"^(M|F|U)$")]

    # по доке (пример): birthdate "YYYY-MM-DD" :contentReference[oaicite:5]{index=5}
    birthdate: Annotated[str, GeneratingRule(regex=r"^(19|20)\d{2}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$")]

    # по доке: addresses[] :contentReference[oaicite:6]{index=6}
    addresses: List[PersonAddressRequest]
================================================================================
FILE: ./src/api/models/comparison/model_assertions.py
================================================================================
from typing import Any

from src.api.models.comparison.model_comparator import ModelComparator
from src.api.models.comparison.model_comparison_configuration import ModelComparisonConfigLoader


class ModelAssertions:
    def __init__(self, request: Any, response: Any):
        self.request = request
        self.response = response

    def match(self) -> 'ModelAssertions':
        config_loader = ModelComparisonConfigLoader('model-comparison.properties')
        rule = config_loader.get_rule_for(self.request)
        if rule:
            result = ModelComparator.compare_fields(self.request, self.response, rule.field_mapping
                                                    )
            if not result.is_success():
                raise AssertionError(f'Model comparison failed with mismatches fields \n {result.mismatches}')
        else:
            raise AssertionError(f'Model comparison rule found for   \n {self.request.__class__.__name__}')
        return self
================================================================================
FILE: ./src/api/models/comparison/__init__.py
================================================================================

================================================================================
FILE: ./src/api/models/comparison/model_comparator.py
================================================================================
from typing import Any, Dict, List
from dataclasses import dataclass
import re

#TODO: разобраться
@dataclass
class Mismatch:
    field_name: str
    expected: Any
    actual: Any

class ComparisonResult:
    def __init__(self, mismatches: List [Mismatch]):
        self._mismatches =  mismatches

    def is_success(self) -> bool:
        return not self.mismatches

    @property
    def mismatches(self)->List [Mismatch]:
        return self._mismatches

class ModelComparator:
    @staticmethod
    def compare_fields(request: Any, response: Any, field_mapping: Dict[str,str]):
        mismatches = []
        for request_field, response_field in field_mapping.items():
            request_value = ModelComparator._get_field_value(request, request_field)
            response_value = ModelComparator._get_field_value(response, response_field)
            if str(request_value)!=str(response_value):
                mismatches.append(Mismatch(f'{request_field} -> {response_field}', request_value, response_value))
        return ComparisonResult(mismatches)

    @staticmethod
    def _get_field_value(obj: Any, path: str) -> Any:
        """
        Поддерживает пути вида:
        - gender
        - names[0].givenName
        - names[0].familyName
        """
        current = obj

        for part in path.split("."):
            # names[0]
            match = re.match(r"(\w+)\[(\d+)\]", part)
            if match:
                attr_name, index = match.groups()
                index = int(index)

                # attr
                if isinstance(current, dict):
                    current = current[attr_name]
                else:
                    current = getattr(current, attr_name)

                # index
                current = current[index]
            else:
                # обычное поле
                if isinstance(current, dict):
                    current = current[part]
                else:
                    current = getattr(current, part)

        return current

================================================================================
FILE: ./src/api/models/comparison/model_comparison_configuration.py
================================================================================
import os
from pathlib import Path
import configparser
from typing import Dict, Type, Optional


from typing import Dict

class ComparisonRule:
    def __init__(self, response_class_name: str, field_pairs: list[str]):
        self._response_class_name = response_class_name
        self._field_mapping: Dict[str, str] = {}

        for pair in field_pairs:
            parts = pair.split('=')
            if len(parts) == 2:
                self._field_mapping[parts[0].strip()] = parts[1].strip()
            else:
                key = pair.strip()
                self._field_mapping[key] = key

    @property
    def response_class_name(self) -> str:
        return self._response_class_name

    @property
    def field_mapping(self) -> Dict[str, str]:
        return self._field_mapping


class ModelComparisonConfigLoader:
    def __init__(self, config_file: str):
        self.rules : Dict[str, ComparisonRule]= {}
        self._load_config(config_file=config_file)

    def get_rule_for(self, request_class: Type) -> Optional[ComparisonRule]:
        return self.rules.get(type(request_class).__name__)

    def _load_config(self, config_file: str):
        config_path = Path(__file__).parents[4]/"resources" / f'{config_file}'
        if not os.path.exists(config_path):
            raise FileNotFoundError(f'Config file not found')

        config = configparser.ConfigParser()
        config.optionxform = str
        config.read(config_path)

        for key in config.defaults():
            value = config.defaults()[key]
            target = value.split(':')
            if len(target)!= 2:
                continue
            response_class = target[0].strip()
            field_list = [field.strip()  for field in target[1].split(',')]
            self.rules[key.strip()] = ComparisonRule(response_class, field_list)




================================================================================
FILE: ./src/api/requests/admin_user_requester.py
================================================================================
from http import HTTPStatus
from typing import Union

import requests

from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.responses.create_user_response import UserProfileResponse, CreateUserValidationErrorResponse
from src.api.requests.requester import Requester


class AdminUserRequester(Requester):

    def post(self, create_user_request:CreateUserRequest) -> Union[UserProfileResponse, None]:
        url = f"{self.base_url}/admin/users"
        response = requests.post(url=url, headers=self.headers, json=create_user_request.model_dump())
        self.response_spec(response)

        if response.status_code in [HTTPStatus.OK, HTTPStatus.CREATED]:
            return UserProfileResponse(**response.json())
        return None

    def delete(self, id: int):
        url = f"{self.base_url}/admin/users/{id}"
        response = requests.delete(url=url, headers=self.headers, )
        self.response_spec(response)
        return response


================================================================================
FILE: ./src/api/requests/create_account_requester.py
================================================================================
import requests

from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.requests.requester import Requester


class CreateAccountRequester(Requester):

    def post(self) -> UserProfileResponse:
        url = f"{self.base_url}/accounts"
        response = requests.post(url=url, headers=self.headers)
        self.response_spec(response)
        return UserProfileResponse(**response.json())


================================================================================
FILE: ./src/api/requests/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/requester.py
================================================================================
from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import Dict

from src.api.models.base_model import BaseModel


class Requester(ABC):
    def __init__(self, request_spec: Dict[str, str], response_spec: Callable):
        self.headers = request_spec.get('headers')
        self.base_url = request_spec.get('base_url', 'http://localhost:4111')
        self.response_spec = response_spec

    @abstractmethod
    def post(self, model:BaseModel|None):...
================================================================================
FILE: ./src/api/requests/login_user_requester.py
================================================================================
import requests

from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.models.responses.login_user_response import LoginUserResponse
from src.api.requests.requester import Requester



class LoginUserRequester(Requester):

    def post(self, login_user_request: LoginUserRequest) -> LoginUserResponse:
        url = f"{self.base_url}/auth/login"
        response = requests.post(url=url, headers=self.headers, json=login_user_request.model_dump())
        self.response_spec(response)
        return LoginUserResponse(**response.json())



================================================================================
FILE: ./src/api/requests/sceleton/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/endpoint.py
================================================================================
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from src.api.models.base_model import BaseModel
from src.api.models.requests.create_patient_from_person_request import CreatePatientFromPersonRequest
from src.api.models.requests.create_person_request import CreatePersonRequest
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.requests.fund_deposit_request import FundDepositRequest
from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.models.requests.update_profile_request import UpdateProfileRequest
from src.api.models.responses.create_acoount_response import AccountResponse
from src.api.models.responses.create_patient_response import PatientCreateResponse
from src.api.models.responses.create_person_response import CreatPersonResponse, PersonFullResponse
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.models.responses.get_location_response import LocationListResponse
from src.api.models.responses.get_roles_response import RoleListResponse
from src.api.models.responses.login_user_response import LoginUserResponse
from src.api.models.responses.patient_identifier_type_response import PatientIdentifierTypeListResponse


@dataclass(frozen=True)
class EndpointConfig:
    url:str
    request_model:Optional[BaseModel]
    response_model:Optional[BaseModel]

class Endpoint(Enum):
    ADMIN_CREATE_USER = EndpointConfig(url="/admin/users", request_model=CreateUserRequest, response_model=UserProfileResponse)
    ADMIN_DELETE_USER = EndpointConfig(url="/admin/users",request_model=None,response_model=None)
    LOGIN_USER = EndpointConfig(url="/auth/login", request_model=LoginUserRequest, response_model=LoginUserResponse)
    CREATE_ACCOUNT = EndpointConfig(url="/accounts", request_model=None, response_model=AccountResponse)
    FUND_DEPOSIT = EndpointConfig(url="/accounts/deposit", request_model=FundDepositRequest, response_model=AccountResponse)
    GET_CUSTOMER_PROFILE = EndpointConfig(url="/customer/profile", request_model=None, response_model=UserProfileResponse)
    UPDATE_CUSTOMER_PROFILE = EndpointConfig(url="/customer/profile", request_model=UpdateProfileRequest, response_model=None)
    GET_ROLES = EndpointConfig(
        url="/role",
        request_model=None,
        response_model=RoleListResponse
    )

    GET_LOCATIONS = EndpointConfig(
        url="/location",
        request_model=None,
        response_model=LocationListResponse
    )

    GET_PATIENT_IDENTIFIER_TYPES = EndpointConfig(
        url="/patientidentifiertype",
        request_model=None,
        response_model=PatientIdentifierTypeListResponse
    )
    CREATE_PERSON = EndpointConfig(
        url="/person",
        request_model=CreatePersonRequest,
        response_model=CreatPersonResponse
    )

    GET_PERSON = EndpointConfig(
        url="/person",
        request_model=None,
        response_model=PersonFullResponse
    )

    DELETE_PERSON = EndpointConfig(
        url="/person",
        request_model=None,
        response_model=None
    )

    CREATE_PATIENT_FROM_PERSON = EndpointConfig(
        url="/patient",
        request_model=CreatePatientFromPersonRequest,
        response_model=PatientCreateResponse
    )

    DELETE_PATIENT = EndpointConfig(
        url="/patient",
        request_model=None,
        response_model=None
    )
================================================================================
FILE: ./src/api/requests/sceleton/http_request.py
================================================================================
from collections.abc import Callable
from typing import Protocol, Dict

from src.api.requests.sceleton.endpoint import Endpoint


class HTTPRequest(Protocol):
    def __init__(self, request_spec: Dict[str,str], endpoint: Endpoint, response_spec: Callable):
        self.request_spec = request_spec
        self.endpoint = endpoint
        self.response_spec = response_spec
================================================================================
FILE: ./src/api/requests/sceleton/requesters/validated_crud_requester.py
================================================================================
from typing import TypeVar, Dict, Callable, Optional, Any

from src.api.models.base_model import BaseModel
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.http_request import HTTPRequest
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester

T = TypeVar('T', bound=BaseModel)


class ValidatedCrudRequester(HTTPRequest):
    def __init__(self, request_spec: Dict[str, str], endpoint: Endpoint, response_spec: Callable):
        super().__init__(request_spec, endpoint, response_spec)
        self.crud_requester = CrudRequester(request_spec = request_spec, endpoint = endpoint, response_spec = response_spec)

    def post(self, model: Optional[T] = None):
        response = self.crud_requester.post(model= model)
        return self.endpoint.value.response_model.model_validate(response.json())

    def get(self, id: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        response = self.crud_requester.get(id=id, params=params)
        return self.endpoint.value.response_model.model_validate(response.json())

    def update(self,  model: T):
        response = self.crud_requester.update(model=model)
        return self.endpoint.value.response_model.model_validate(response.json())


================================================================================
FILE: ./src/api/requests/sceleton/requesters/__init__.py
================================================================================

================================================================================
FILE: ./src/api/requests/sceleton/requesters/crud_requester.py
================================================================================
from http import HTTPStatus
from typing import Protocol, Optional, Union, TypeVar, Dict, Any

import requests
from requests import Response

from src.api.configs.config import Config
from src.api.models.base_model import BaseModel
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.requests.sceleton.http_request import HTTPRequest
from src.api.requests.sceleton.interfaces.crud_end_interface import CrudEndPointInterface

#дженерик, позволяющий сохранять строгую типизацию
T = TypeVar('T', bound=BaseModel)

class CrudRequester(HTTPRequest, CrudEndPointInterface):
    #TODO мы же наслодовались тут почему возвращаемы тип другой - не бейс модел
    def post(self, model: Optional[T]) -> Response:
        #TODO: optimize
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')


        body = model.model_dump() if model else ''
        response = requests.post(url=f'{server_url}{api_version_url}{self.endpoint.value.url}',
                                 headers=self.request_spec, json=body)
        self.response_spec(response)
        return response



    def get(self, model: Optional[BaseModel] = None, id: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}'
        if id:
            url = f"{url}/{id}"

        response = requests.get(url=url, headers=self.request_spec, params=params)
        self.response_spec(response)
        return response

    def update(self, model: Optional[BaseModel] = None) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}'
        body = model.model_dump() if model else {}

        response = requests.put(
            url=url,
            headers=self.request_spec,
            json=body
        )

        self.response_spec(response)
        return response

    #TODO мы же наслодовались тут почему возвращаемы тип другой - не бейс модел
    def delete(self, id: int) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        response = requests.delete(url=f'{server_url}{api_version_url}{self.endpoint.value.url}/{id}',
                                 headers=self.request_spec)
        self.response_spec(response)
        return response

    def delete_with_params(self, id: str, params: Optional[Dict[str, Any]] = None) -> Response:
        server_url = Config.get('server')
        api_version_url = Config.get('api_version')

        url = f'{server_url}{api_version_url}{self.endpoint.value.url}/{id}'
        response = requests.delete(url=url, headers=self.request_spec, params=params)
        self.response_spec(response)
        return response

================================================================================
FILE: ./src/api/requests/sceleton/interfaces/crud_end_interface.py
================================================================================
from typing import Protocol, Optional, Union

from src.api.models.base_model import BaseModel


class CrudEndPointInterface(Protocol):
    def post(self, model: BaseModel) -> BaseModel: ...

    def get(self, model: Optional[BaseModel] = None, id : Optional[int] = None) -> BaseModel: ...

    def update(self, model: Optional[BaseModel] = None, id: Optional[int] = None) -> BaseModel: ...

    def delete(self, id: int) -> Union[BaseModel, bool]: ...

================================================================================
FILE: ./src/api/steps/__init__.py
================================================================================

================================================================================
FILE: ./src/api/steps/admin_steps.py
================================================================================
from typing import Union

from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.comparison.model_assertions import ModelAssertions
from src.api.models.requests.create_patient_from_person_request import CreatePatientFromPersonRequest
from src.api.models.requests.create_person_request import CreatePersonRequest
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.responses.create_patient_response import PatientCreateResponse
from src.api.models.responses.create_person_response import CreatPersonResponse, PersonFullResponse
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.requests.sceleton.requesters.validated_crud_requester import ValidatedCrudRequester
from src.api.specs.request_spec import RequestSpecs
from src.api.specs.response_spec import ResponseSpecs
from src.api.steps.base_steps import BaseSteps





class AdminSteps(BaseSteps):

    def create_valid_user(self, create_user_request:CreateUserRequest = RandomModelGenerator.generate(CreateUserRequest)) -> Union[UserProfileResponse, None]:


        create_user_response: UserProfileResponse = ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.ADMIN_CREATE_USER,
            response_spec=ResponseSpecs.entity_was_created()
        ).post(create_user_request)


        ModelAssertions(create_user_request,create_user_response).match()

        self.created_objects.append(create_user_response)

        return create_user_response

    def create_invalid_user(self, create_user_request:CreateUserRequest, error_key, error_value):

        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.ADMIN_CREATE_USER,
            response_spec=ResponseSpecs.request_returns_bad_request(error_key,error_value)
        ).post(create_user_request)


    def delete_user(self,user_id: int):

        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.ADMIN_DELETE_USER,
            response_spec=ResponseSpecs.entity_was_deleted()
        ).delete(user_id)

    def get_roles(self):
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_ROLES,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    def get_locations(self):
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_LOCATIONS,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    def get_patient_identifier_types(self):
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_PATIENT_IDENTIFIER_TYPES,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    def create_person(self, create_person_request: CreatePersonRequest) -> CreatPersonResponse:
        person = ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.CREATE_PERSON,
            response_spec=ResponseSpecs.entity_was_created()
        ).post(create_person_request)

        full = self.get_person_full(person.uuid)
        ModelAssertions(create_person_request, full).match()
        self.created_objects.append(person)
        return person

    def get_person_full(self, person_uuid: str) -> PersonFullResponse:
        return ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.GET_PERSON,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get(id=person_uuid, params={"v": "full"})

    def delete_person(self, person_uuid: str, purge: bool = True):
        params = {"purge": "true"} if purge else None

        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.DELETE_PERSON,
            response_spec=ResponseSpecs.entity_was_deleted()
        ).delete_with_params(id=person_uuid, params=params)

    def create_patient_from_person(self, req: CreatePatientFromPersonRequest) -> PatientCreateResponse:
        patient = ValidatedCrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.CREATE_PATIENT_FROM_PERSON,
            response_spec=ResponseSpecs.entity_was_created()
        ).post(req)

        self.created_objects.append(patient)
        return patient

    def delete_patient(self, patient_uuid: str, purge: bool = True):
        params = {"purge": "true"} if purge else None
        CrudRequester(
            request_spec=RequestSpecs.admin_auth_spec(),
            endpoint=Endpoint.DELETE_PATIENT,
            response_spec=ResponseSpecs.entity_was_deleted()
        ).delete_with_params(id=patient_uuid, params=params)

    #TODO: удалять персон





================================================================================
FILE: ./src/api/steps/user_steps.py
================================================================================
from typing import Dict

from src.api.models.comparison.model_assertions import ModelAssertions
from src.api.models.requests.create_user_request import CreateUserRequest
from src.api.models.requests.fund_deposit_request import FundDepositRequest
from src.api.models.requests.login_user_request import LoginUserRequest
from src.api.models.requests.update_profile_request import UpdateProfileRequest
from src.api.models.responses.create_acoount_response import AccountResponse
from src.api.models.responses.create_user_response import UserProfileResponse
from src.api.models.responses.login_user_response import LoginUserResponse
from src.api.requests.sceleton.endpoint import Endpoint
from src.api.requests.sceleton.requesters.crud_requester import CrudRequester
from src.api.requests.sceleton.requesters.validated_crud_requester import ValidatedCrudRequester
from src.api.specs.request_spec import RequestSpecs
from src.api.specs.response_spec import ResponseSpecs
from src.api.steps.base_steps import BaseSteps


class UserSteps(BaseSteps):
    # --- helpers ---
    def _auth_headers(self, user: CreateUserRequest) -> Dict[str, str]:
        return RequestSpecs.user_auth_spec(user.username, user.password)

    def _get_profile(self, headers: Dict[str, str]) -> UserProfileResponse:
        return ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.GET_CUSTOMER_PROFILE,
            response_spec=ResponseSpecs.request_returns_ok()
        ).get()

    # --- steps ---
    def login(self, user_request: CreateUserRequest) -> LoginUserResponse:
        login_request = LoginUserRequest(username=user_request.username, password=user_request.password)

        login_user_response: LoginUserResponse = ValidatedCrudRequester(
            request_spec=RequestSpecs.unauth_spec(),
            endpoint=Endpoint.LOGIN_USER,
            response_spec=ResponseSpecs.request_returns_ok()
        ).post(login_request)

        ModelAssertions(login_request, login_user_response).match()

        self.created_objects.append(login_user_response)
        return login_user_response

    def create_account(self, create_user_request: CreateUserRequest) -> AccountResponse:
        headers = self._auth_headers(create_user_request)

        create_account_response: AccountResponse = ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.CREATE_ACCOUNT,
            response_spec=ResponseSpecs.entity_was_created()
        ).post()

        assert create_account_response.balance == 0.0
        assert create_account_response.transactions == []
        assert create_account_response.id

        return create_account_response

    def fund_deposit(self, create_user_request: CreateUserRequest) -> AccountResponse:
        headers = self._auth_headers(create_user_request)

        create_account_response: AccountResponse = ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.CREATE_ACCOUNT,
            response_spec=ResponseSpecs.entity_was_created()
        ).post()

        assert create_account_response.balance == 0.0
        assert create_account_response.transactions == []
        assert create_account_response.id

        fund_deposit_request = FundDepositRequest(id=create_account_response.id, balance=100.00)

        deposit_response: AccountResponse = ValidatedCrudRequester(
            request_spec=headers,
            endpoint=Endpoint.FUND_DEPOSIT,
            response_spec=ResponseSpecs.request_returns_ok()
        ).post(fund_deposit_request)

        return deposit_response

    def get_customer_profile(self, create_user_request: CreateUserRequest) -> UserProfileResponse:
        headers = self._auth_headers(create_user_request)
        return self._get_profile(headers)

    def update_customer_profile(
        self,
        create_user_request: CreateUserRequest, update_profile_request: UpdateProfileRequest
    ) -> UserProfileResponse:

        headers = self._auth_headers(create_user_request)

        profile_response_before_update = self._get_profile(headers)
        assert profile_response_before_update.name is None

        CrudRequester(
            request_spec=headers,
            endpoint=Endpoint.UPDATE_CUSTOMER_PROFILE,
            response_spec=ResponseSpecs.request_returns_ok()
        ).update(update_profile_request)

        profile_response_after_update = self._get_profile(headers)
        assert profile_response_after_update.name == update_profile_request.name

        return profile_response_after_update

    def invalid_update_customer_profile(
        self,
        create_user_request: CreateUserRequest, name: str, error_key: str, error_value: str
    ):

        update_profile_request = UpdateProfileRequest(name= name)

        CrudRequester(
            request_spec=RequestSpecs.user_auth_spec(create_user_request.username, create_user_request.password),
            endpoint=Endpoint.UPDATE_CUSTOMER_PROFILE,
            response_spec=ResponseSpecs.request_returns_bad_request(error_key=error_key, error_value=error_value)
        ).update(update_profile_request)
================================================================================
FILE: ./src/api/steps/base_steps.py
================================================================================
from typing import List, Any


class BaseSteps:
    def __init__(self, created_objects: List[Any]):
        self.created_objects = created_objects
================================================================================
FILE: ./src/api/configs/config.py
================================================================================
import configparser
from pathlib import Path
from typing import Any


class Config:
    config = None
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Config, cls).__new__(cls)
            config_path = Path(__file__).parents[3]/"resources"/"config.properties"

            cls.config = configparser.ConfigParser()
            cls.config.read(config_path)
        return cls._instance

    @staticmethod
    def get(key:str, default_value: Any = None):
        return Config().config["DEFAULT"].get(key, fallback=default_value)



================================================================================
FILE: ./src/api/configs/__init__.py
================================================================================

================================================================================
FILE: ./src/api/fixtures/api_fixtures.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager


@pytest.fixture
def api_manager(created_objects) -> ApiManager:
    return ApiManager(created_objects)
================================================================================
FILE: ./src/api/fixtures/user_fixtures.py
================================================================================
import pytest

from src.api.classes.api_manager import ApiManager
from src.api.generators.random_model_generator import RandomModelGenerator
from src.api.models.requests.create_user_request import CreateUserRequest


@pytest.fixture
def user_request(api_manager: ApiManager) -> CreateUserRequest:
    user_data: CreateUserRequest = RandomModelGenerator.generate(CreateUserRequest)
    api_manager.admin_steps.create_valid_user(user_data)
    return user_data


@pytest.fixture
def admin_user_request() -> CreateUserRequest:
    return CreateUserRequest(username="admin", password="admin", role='ADMIN')
================================================================================
FILE: ./src/api/fixtures/objects_fixture.py
================================================================================
import logging

import pytest

from src.api.classes.api_manager import ApiManager
from src.api.models.responses.create_user_response import UserProfileResponse


def cleanup_object(objects: list):
    api_manager = ApiManager(objects)
    for obj in objects:
        if isinstance(obj, UserProfileResponse):
            api_manager.admin_steps.delete_user(obj.id)
        else:
            logging.warning(f'Object type: {type(obj)} is not deleted')


@pytest.fixture
def created_objects():
    objects: list = []
    yield objects
    cleanup_object(objects)
================================================================================
FILE: ./src/api/generators/random_model_generator.py
================================================================================
import random
import uuid
from datetime import datetime, timedelta
from typing import get_type_hints, Any, get_origin, Annotated, get_args, Union
from datetime import date, timedelta


import rstr

from src.api.generators.generating_rule import GeneratingRule
from src.api.generators.mod30 import generate_mod30_identifier, luhn_mod_n_is_valid
from src.api.models.requests.create_patient_from_person_request import PatientIdentifierRequest


class RandomModelGenerator:
    @staticmethod
    def generate(cls: type) -> Any:
        type_hints = get_type_hints(cls, include_extras=True)
        init_data = {}

        for field_name, annotated_type in type_hints.items():
            rule = None
            actual_type = annotated_type

            if get_origin(annotated_type) is Annotated:
                actual_type, *annotations = get_args(annotated_type)
                for ann in annotations:
                    if isinstance(ann, GeneratingRule):
                        rule = ann

            if cls is PatientIdentifierRequest and field_name == "identifier":
                # например, длина 10 (можно сделать randint)
                value = generate_mod30_identifier(total_len=random.randint(6, 12))
                # самопроверка (на всякий)
                assert luhn_mod_n_is_valid(value), f"Generated invalid Mod-30 id: {value}"
                init_data[field_name] = value
                continue

            if field_name == "birthdate" and actual_type is str:
                days_ago = random.randint(0, 365 * 90)
                d = date.today() - timedelta(days=days_ago)
                init_data[field_name] = d.isoformat()
                continue

            if rule:
                value = RandomModelGenerator._generate_from_regex(
                    rule.regex,
                    actual_type
                )
            else:
                value = RandomModelGenerator._generate_value(actual_type)
            init_data[field_name] = value
        return cls(**init_data)


    @staticmethod
    def _generate_from_regex(regex: str, field_type: type) -> Any:
        generated = rstr.xeger(regex)

        if field_type is int:
            return int(generated)

        if field_type is float:
            return float(generated)

        return generated

    @staticmethod
    def _generate_value(field_type: Any) -> Any:
        origin = get_origin(field_type)

        # Optional[T] -> Union[T, NoneType]
        if origin is Union:
            args = [a for a in get_args(field_type)]
            non_none = [a for a in args if a is not type(None)]
            # чаще генерим значение, иногда None
            if not non_none or random.random() < 0.2:
                return None
            return RandomModelGenerator._generate_value(non_none[0])

        # List[T]
        if origin in (list,):
            (item_type,) = get_args(field_type) or (str,)
            # для REST-запроса на создание обычно достаточно 1 элемента
            return [RandomModelGenerator._generate_value(item_type)]

        # базовые типы
        if field_type is str:
            return str(uuid.uuid4())[:8]
        elif field_type is int:
            return random.randint(0, 1000)
        elif field_type is float:
            return round(random.uniform(0, 100.0), 2)
        elif field_type is bool:
            return random.choice([True, False])
        elif field_type is datetime:
            return datetime.now() - timedelta(seconds=random.randint(0, 100000))

        # вложенные модели (Pydantic)
        if isinstance(field_type, type):
            return RandomModelGenerator.generate(field_type)

        return None



================================================================================
FILE: ./src/api/generators/__init__.py
================================================================================

================================================================================
FILE: ./src/api/generators/random_data.py
================================================================================
import string

from faker import Faker
import random

#TODO: почему это костыль?
class RandomData:
    faker = Faker()

    @staticmethod
    def get_valid_username() -> str:
        length = random.randint(3, 15)
        return "".join(
            RandomData.faker.random_letters(length=length))

    @staticmethod
    def get_valid_password() -> str:
        upper = random.sample(string.ascii_uppercase, 3)
        lower = random.sample(string.ascii_lowercase, 3)
        digits = random.sample(string.digits, 3)
        special = random.choice("!@#$%")

        pwd = upper + lower + digits + [special]
        random.shuffle(pwd)
        return "".join(pwd)
================================================================================
FILE: ./src/api/generators/generating_rule.py
================================================================================
from dataclasses import dataclass

@dataclass
class GeneratingRule:
    regex: str
================================================================================
FILE: ./src/api/generators/mod30.py
================================================================================
from __future__ import annotations

import random
from typing import Final

# charset из практики OpenMRS Mod-30 (без B I O Q S Z)
MOD30_ALPHABET: Final[str] = "0123456789ACDEFGHJKLMNPRTUVWXY"

def luhn_mod_n_check_char(body: str, alphabet: str = MOD30_ALPHABET) -> str:
    """
    Возвращает check-character для Luhn mod N (N = len(alphabet)),
    предполагая что body состоит ТОЛЬКО из символов alphabet.
    """
    n = len(alphabet)
    if n % 2 != 0:
        raise ValueError("Luhn mod N requires even N (alphabet length must be even).")

    # индекс символа -> code point
    idx = {ch: i for i, ch in enumerate(alphabet)}

    factor = 2
    total = 0

    # идём справа налево по body
    for ch in reversed(body):
        try:
            code_point = idx[ch]
        except KeyError:
            raise ValueError(f"Invalid char {ch!r} for alphabet") from None

        addend = factor * code_point
        factor = 1 if factor == 2 else 2

        # "сумма цифр" в базе n
        addend = (addend // n) + (addend % n)
        total += addend

    remainder = total % n
    check_code_point = (n - remainder) % n
    return alphabet[check_code_point]


def luhn_mod_n_is_valid(value: str, alphabet: str = MOD30_ALPHABET) -> bool:
    """
    Проверяет строку, где последний символ — check-character.
    """
    n = len(alphabet)
    if n % 2 != 0 or len(value) < 2:
        return False

    idx = {ch: i for i, ch in enumerate(alphabet)}
    factor = 1
    total = 0

    for ch in reversed(value):
        if ch not in idx:
            return False
        code_point = idx[ch]
        addend = factor * code_point
        factor = 1 if factor == 2 else 2
        addend = (addend // n) + (addend % n)
        total += addend

    return (total % n) == 0


def generate_mod30_identifier(total_len: int = 10, alphabet: str = MOD30_ALPHABET) -> str:
    """
    total_len — полная длина идентификатора (включая check-character).
    """
    if total_len < 2:
        raise ValueError("total_len must be >= 2")

    body_len = total_len - 1
    body = "".join(random.choice(alphabet) for _ in range(body_len))
    check = luhn_mod_n_check_char(body, alphabet)
    return body + check
